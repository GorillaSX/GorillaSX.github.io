<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xin Song</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gorillasx.github.io/"/>
  <updated>2019-03-07T02:16:36.000Z</updated>
  <id>https://gorillasx.github.io/</id>
  
  <author>
    <name>Xin Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Preparing For Interview Day 11</title>
    <link href="https://gorillasx.github.io/2018/06/29/Preparing-For-Interview-Day-11/"/>
    <id>https://gorillasx.github.io/2018/06/29/Preparing-For-Interview-Day-11/</id>
    <published>2018-06-29T14:32:36.000Z</published>
    <updated>2019-03-07T02:16:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-733-Flood-Fill"><a href="#1-Leetcode-733-Flood-Fill" class="headerlink" title="1. Leetcode 733. Flood Fill"></a>1. <a href="https://leetcode.com/problems/flood-fill/description/" target="_blank" rel="noopener">Leetcode 733. Flood Fill</a></h4><p>An image is represented by a 2-D array of integers, each integer representing the pixel value of the image (from 0 to 65535).</p><p>Given a coordinate (sr, sc) representing the starting pixel (row and column) of the flood fill, and a pixel value newColor, “flood fill” the image.</p><p>To perform a “flood fill”, consider the starting pixel, plus any pixels connected 4-directionally to the starting pixel of the same color as the starting pixel, plus any pixels connected 4-directionally to those pixels (also with the same color as the starting pixel), and so on. Replace the color of all of the aforementioned pixels with the newColor.</p><p>At the end, return the modified image.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; floodFill(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor) &#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? image[<span class="number">0</span>].size() :<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(image[sr][sc] == newColor)</span><br><span class="line">            <span class="keyword">return</span> image;</span><br><span class="line">        DFS(image, m, n, sr, sc, newColor);</span><br><span class="line">        <span class="keyword">return</span> image;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; image, <span class="keyword">int</span> m ,<span class="keyword">int</span> n, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> newColor)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tmp = image[sr][sc];</span><br><span class="line">        image[sr][sc] = newColor;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> r = sr + delta[i];</span><br><span class="line">           <span class="keyword">int</span> c = sc + delta[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; image[r][c] == tmp)</span><br><span class="line">                DFS(image, m,n, r, c, newColor);   </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-376-Wiggle-Subsequence"><a href="#2-Leetcode-376-Wiggle-Subsequence" class="headerlink" title="2. Leetcode 376. Wiggle Subsequence"></a>2. <a href="https://leetcode.com/problems/wiggle-subsequence/description/" target="_blank" rel="noopener">Leetcode 376. Wiggle Subsequence</a></h4><p>A sequence of numbers is called a wiggle sequence if the differences between successive numbers strictly alternate between positive and negative. The first difference (if one exists) may be either positive or negative. A sequence with fewer than two elements is trivially a wiggle sequence.</p><p>For example, [1,7,4,9,2,5] is a wiggle sequence because the differences (6,-3,5,-7,3) are alternately positive and negative. In contrast, [1,4,7,2,5] and [1,7,4,5,5] are not wiggle sequences, the first because its first two differences are positive and the second because its last difference is zero.</p><p>Given a sequence of integers, return the length of the longest subsequence that is a wiggle sequence. A subsequence is obtained by deleting some number of elements (eventually, also zero) from the original sequence, leaving the remaining elements in their original order.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">wiggleMaxLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; endWithPositive(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; endWithNegitive(nums.size(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            endWithPositive[i] = endWithPositive[i<span class="number">-1</span>];</span><br><span class="line">            endWithNegitive[i] = endWithNegitive[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">                endWithPositive[i] = endWithNegitive[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(nums[i] &lt; nums[i<span class="number">-1</span>])</span><br><span class="line">                endWithNegitive[i] = endWithPositive[i<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> max(endWithPositive.back(), endWithNegitive.back());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-473-Matchsticks-to-Square"><a href="#3-Leetcode-473-Matchsticks-to-Square" class="headerlink" title="3. Leetcode 473. Matchsticks to Square"></a>3. <a href="https://leetcode.com/problems/matchsticks-to-square/description/" target="_blank" rel="noopener">Leetcode 473. Matchsticks to Square</a></h4><p>Remember the story of Little Match Girl? By now, you know exactly what matchsticks the little match girl has, please find out a way you can make one square by using up all those matchsticks. You should not break any stick, but you can link them up, and each matchstick must be used exactly one time.</p><p>Your input will be several matchsticks the girl has, represented with their stick length. Your output will either be true or false, to represent whether you could make one square using all the matchsticks the little match girl has.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">makesquare</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(nums.size() &lt; <span class="number">4</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       sort(nums.begin(), nums.end());</span><br><span class="line">       <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            totalSum += n;</span><br><span class="line">       <span class="keyword">if</span>(totalSum % <span class="number">4</span> != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">       <span class="keyword">int</span> target = totalSum / <span class="number">4</span>;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt; visited(nums.size(), <span class="literal">false</span>);    </span><br><span class="line">       <span class="keyword">return</span> DFS(<span class="number">4</span>, <span class="number">0</span>, target, <span class="number">0</span>, <span class="number">0</span>,  visited, nums); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFS</span><span class="params">(<span class="keyword">int</span> side, <span class="keyword">int</span> currentSide, <span class="keyword">int</span> target, <span class="keyword">int</span> curSum, <span class="keyword">int</span> index, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&amp; visited, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(currentSide == side)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(curSum &gt; target)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(curSum == target)</span><br><span class="line">            <span class="keyword">return</span> DFS(side, currentSide + <span class="number">1</span>, target, <span class="number">0</span>, <span class="number">0</span>, visited, nums);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = index; i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                visited[i] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(DFS(side, currentSide, target, curSum + nums[i], i + <span class="number">1</span>, visited, nums))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">                visited[i] =<span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-120-Triangle"><a href="#4-Leetcode-120-Triangle" class="headerlink" title="4. Leetcode 120. Triangle"></a>4. <a href="https://leetcode.com/problems/triangle/description/" target="_blank" rel="noopener">Leetcode 120. Triangle</a></h4><p>Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumTotal</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; triangle)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = triangle.size();</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m - <span class="number">2</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; triangle[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                triangle[i][j] = triangle[i][j] + (min(triangle[i+<span class="number">1</span>][j], triangle[i+<span class="number">1</span>][j+<span class="number">1</span>]));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> triangle[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-721-Accounts-Merge"><a href="#5-Leetcode-721-Accounts-Merge" class="headerlink" title="5. Leetcode 721. Accounts Merge"></a>5. <a href="https://leetcode.com/problems/accounts-merge/description/" target="_blank" rel="noopener">Leetcode 721. Accounts Merge</a></h4><p>Given a list accounts, each element accounts[i] is a list of strings, where the first element accounts[i][0] is a name, and the rest of the elements are emails representing emails of the account.</p><p>Now, we would like to merge these accounts. Two accounts definitely belong to the same person if there is some email that is common to both accounts. Note that even if two accounts have the same name, they may belong to different people as people could have the same name. A person can have any number of accounts initially, but all of their accounts definitely have the same name.</p><p>After merging the accounts, return the accounts in the following format: the first element of each account is the name, and the rest of the elements are emails in sorted order. The accounts themselves can be returned in any </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; accountsMerge(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; accounts) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; EmailToAccount;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; accounts.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; accounts[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                EmailToAccount[accounts[i][j]].push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents(accounts.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; parents.size();i++)</span><br><span class="line">            parents[i]= i;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : EmailToAccount)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; connectAccount = ele.second;</span><br><span class="line">            <span class="keyword">int</span> left = connectAccount[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">int</span> tmpl = left;</span><br><span class="line">            <span class="keyword">while</span>(parents[tmpl] != tmpl)</span><br><span class="line">                tmpl = parents[tmpl];    </span><br><span class="line">            parents[left] = tmpl;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; connectAccount.size();i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> right = connectAccount[i];</span><br><span class="line">                <span class="keyword">int</span> tmpr = right;</span><br><span class="line">                <span class="keyword">while</span>(parents[tmpr] != tmpr)</span><br><span class="line">                    tmpr = parents[tmpr];</span><br><span class="line">                <span class="keyword">if</span>(tmpl != tmpr)</span><br><span class="line">                &#123;</span><br><span class="line">                    parents[tmpr] = tmpl;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">set</span>&lt;<span class="built_in">string</span>&gt;&gt; accountToEmail;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; accounts.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> node = i;</span><br><span class="line">            <span class="keyword">while</span>(parents[node] != node)</span><br><span class="line">                node = parents[node];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; accounts[i].size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                accountToEmail[node].insert(accounts[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> account : accountToEmail)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;  acc;</span><br><span class="line">           acc.push_back(accounts[account.first][<span class="number">0</span>]);</span><br><span class="line">           acc.insert(acc.end(), account.second.begin(), account.second.end());      </span><br><span class="line">           results.push_back(acc); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-117-Populating-Next-Right-Pointers-in-Each-Nnode-2"><a href="#6-Leetcode-117-Populating-Next-Right-Pointers-in-Each-Nnode-2" class="headerlink" title="6. Leetcode 117. Populating Next Right Pointers in Each Nnode 2"></a>6. <a href="https://leetcode.com/problems/populating-next-right-pointers-in-each-node-ii/description/" target="_blank" rel="noopener">Leetcode 117. Populating Next Right Pointers in Each Nnode 2</a></h4><p>Given a binary tree</p><p>struct TreeLinkNode {<br>  TreeLinkNode <em>left;<br>  TreeLinkNode </em>right;<br>  TreeLinkNode *next;<br>}<br>Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.</p><p>Initially, all next pointers are set to NULL.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for binary tree with next pointer.</span></span><br><span class="line"><span class="comment"> * struct TreeLinkNode &#123;</span></span><br><span class="line"><span class="comment"> *  int val;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode *left, *right, *next;</span></span><br><span class="line"><span class="comment"> *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeLinkNode* <span class="title">FindNext</span><span class="params">(TreeLinkNode* node)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            <span class="keyword">return</span> node-&gt;left;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            <span class="keyword">return</span> node-&gt;right;</span><br><span class="line">        <span class="keyword">return</span> FindNext(node-&gt;next);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">connect</span><span class="params">(TreeLinkNode *root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        TreeLinkNode* node = root;</span><br><span class="line">        <span class="keyword">while</span>(node != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">                    node-&gt;left-&gt;next = node-&gt;right;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    node-&gt;left-&gt;next = FindNext(node-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                node-&gt;right-&gt;next = FindNext(node-&gt;next);</span><br><span class="line">            &#125;</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            connect(root-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            connect(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            connect(FindNext(root-&gt;next));</span><br><span class="line">            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h3><h4 id="1-Leetcode-315-Count-of-Smaller-Numbers-After-Self"><a href="#1-Leetcode-315-Count-of-Smaller-Numbers-After-Self" class="headerlink" title="1. Leetcode 315. Count of Smaller Numbers After Self"></a>1. <a href="https://leetcode.com/problems/count-of-smaller-numbers-after-self/description/" target="_blank" rel="noopener">Leetcode 315. Count of Smaller Numbers After Self</a></h4><p>You are given an integer array nums and you have to return a new counts array. The counts array has the property where counts[i] is the number of smaller elements to the right of nums[i].</p><p><strong>Thought:</strong><br>We can sort nums, then if we want to compare two number, we only need to compare their index of sorted num.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">update</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp;bit, <span class="keyword">int</span> i, <span class="keyword">int</span> val)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(i &lt; bit.size())</span><br><span class="line">        &#123;</span><br><span class="line">            bit[i] += val;</span><br><span class="line">            i += (i &amp; -i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; bit, <span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(index &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            count += bit[index];</span><br><span class="line">            index -= (index &amp; -index);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countSmaller(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sorted = nums;</span><br><span class="line">        sort(sorted.begin(), sorted.end());</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; indexes;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; sorted.size();i++)</span><br><span class="line">            hash[sorted[i]] = i + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bit = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size()+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            result[i] = sum(bit, indexes[nums[i]] - <span class="number">1</span>);</span><br><span class="line">            update(bit, indexes[nums[i]], <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-317-Shortest-Distance-From-All-Buildings"><a href="#2-Leetcode-317-Shortest-Distance-From-All-Buildings" class="headerlink" title="2. Leetcode 317. Shortest Distance From All Buildings"></a>2. <a href="https://leetcode.com/problems/shortest-distance-from-all-buildings/description/" target="_blank" rel="noopener">Leetcode 317. Shortest Distance From All Buildings</a></h4><p>You want to build a house on an empty land which reaches all buildings in the shortest amount of distance. You can only move up, down, left and right. You are given a 2D grid of values 0, 1 or 2, where:</p><p>Each 0 marks an empty land which you can pass by freely.<br>Each 1 marks a building which you cannot pass through.<br>Each 2 marks an obstacle which you cannot pass through.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; distance(m, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;(n , make_pair(<span class="number">0</span>,<span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">int</span> buildings = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    buildings++;</span><br><span class="line">                    BFSUpdateDistance(grid, distance, i, j, m, n);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> res = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(distance[i][j].first == buildings)</span><br><span class="line">                &#123;</span><br><span class="line">                    res = min(res, distance[i][j].second);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res == INT_MAX ? <span class="number">-1</span> : res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">BFSUpdateDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt;&amp; distances, <span class="keyword">int</span> row, <span class="keyword">int</span> col, <span class="keyword">int</span> m, <span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        visited[row][col] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; position;</span><br><span class="line">        position.push(make_pair(row, col));</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!position.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = position.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> p = position.front();</span><br><span class="line">                position.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j =  <span class="number">0</span>;j &lt; <span class="number">4</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = p.first  + delta[j];</span><br><span class="line">                    <span class="keyword">int</span> c = p.second + delta[j+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; visited[r][c] == <span class="literal">false</span> &amp;&amp; grid[r][c] == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        position.push(make_pair(r, c));</span><br><span class="line">                        visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                        distances[r][c].second += distance;</span><br><span class="line">                        distances[r][c].first += <span class="number">1</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            distance++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-239-Sliding-Window-Maximum"><a href="#3-Leetcode-239-Sliding-Window-Maximum" class="headerlink" title="3. Leetcode 239. Sliding Window Maximum"></a>3. <a href="https://leetcode.com/problems/sliding-window-maximum/description/" target="_blank" rel="noopener">Leetcode 239. Sliding Window Maximum</a></h4><p>Given an array nums, there is a sliding window of size k which is moving from the very left of the array to the very right. You can only see the k numbers in the window. Each time the sliding window moves right by one position. Return the max sliding window.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSlidingWindow(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">deque</span>&lt;<span class="keyword">int</span>&gt; deq;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span>  i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(!deq.empty() &amp;&amp; nums[deq.back()] &lt;= nums[i])</span><br><span class="line">            &#123;</span><br><span class="line">                deq.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            deq.push_back(i);</span><br><span class="line">            <span class="keyword">while</span>(!deq.empty() &amp;&amp; i - deq.front() + <span class="number">1</span> &gt; k)</span><br><span class="line">            &#123;</span><br><span class="line">                deq.pop_front();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(i &gt;= k - <span class="number">1</span>)</span><br><span class="line">                res.push_back(nums[deq.front()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-683-K-Empty-Slots"><a href="#4-Leetcode-683-K-Empty-Slots" class="headerlink" title="4. Leetcode 683. K Empty Slots"></a>4. <a href="https://leetcode.com/problems/k-empty-slots/description/" target="_blank" rel="noopener">Leetcode 683. K Empty Slots</a></h4><p>There is a garden with N slots. In each slot, there is a flower. The N flowers will bloom one by one in N days. In each day, there will be exactly one flower blooming and it will be in the status of blooming since then.</p><p>Given an array flowers consists of number from 1 to N. Each number in the array represents the place where the flower will open in that day.</p><p>For example, flowers[i] = x means that the unique flower that blooms at day i will be at position x, where i and x will be in the range from 1 to N.</p><p>Also given an integer k, you need to output in which day there exists two flowers in the status of blooming, and also the number of flowers between them is k and these flowers are not blooming.</p><p>If there isn’t such day, output -1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 10</title>
    <link href="https://gorillasx.github.io/2018/06/28/Preparing-For-Interview-Day-10/"/>
    <id>https://gorillasx.github.io/2018/06/28/Preparing-For-Interview-Day-10/</id>
    <published>2018-06-28T15:15:10.000Z</published>
    <updated>2018-06-28T21:34:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-740-Delete-And-Earn"><a href="#1-Leetcode-740-Delete-And-Earn" class="headerlink" title="1. Leetcode 740. Delete And Earn"></a>1. <a href="https://leetcode.com/problems/delete-and-earn/description/" target="_blank" rel="noopener">Leetcode 740. Delete And Earn</a></h4><p>Given an array nums of integers, you can perform operations on the array.</p><p>In each operation, you pick any nums[i] and delete it to earn nums[i] points. After, you must delete every element equal to nums[i] - 1 or nums[i] + 1.</p><p>You start with 0 points. Return the maximum number of points you can earn by applying such operations.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">deleteAndEarn</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numbers(<span class="number">100002</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            numbers[n]++;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">10000</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">           numbers[i] = max(numbers[i] * i + numbers[i+<span class="number">2</span>], numbers[i+<span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> numbers[<span class="number">0</span>];</span><br><span class="line">   </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-516-Longest-Palindromic-Subsequence"><a href="#2-516-Longest-Palindromic-Subsequence" class="headerlink" title="2. 516. Longest Palindromic Subsequence"></a>2. <a href="https://leetcode.com/problems/longest-palindromic-subsequence/description/" target="_blank" rel="noopener">516. Longest Palindromic Subsequence</a></h4><p>Given a string s, find the longest palindromic subsequence’s length in s. You may assume that the maximum length of s is 1000.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">longestPalindromeSubseq</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> length = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(length, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(length, <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">2</span>; len &lt;= length;len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> start = <span class="number">0</span>; start &lt; length + <span class="number">1</span> - len; start++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> end = start + len - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(s[start] != s[end])</span><br><span class="line">                    dp[start][end] = (end - start == <span class="number">1</span> ? <span class="number">1</span> : max(dp[start+<span class="number">1</span>][end<span class="number">-1</span>], max(dp[start][end<span class="number">-1</span>], dp[start+<span class="number">1</span>][end])));</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[start][end] = (end - start == <span class="number">1</span> ? <span class="number">2</span> : <span class="number">2</span> + dp[start+<span class="number">1</span>][end<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][length<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-718-Maximum-Length-of-repeated-Subarray"><a href="#3-Leetcode-718-Maximum-Length-of-repeated-Subarray" class="headerlink" title="3. Leetcode 718. Maximum Length of repeated Subarray"></a>3. <a href="https://leetcode.com/problems/maximum-length-of-repeated-subarray/description/" target="_blank" rel="noopener">Leetcode 718. Maximum Length of repeated Subarray</a></h4><p>Given two integer arrays A and B, return the maximum length of an subarray that appears in both arrays.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(A.size(), <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(B.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(A[i] == B[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[i][j] = <span class="number">1</span> + ((i - <span class="number">1</span> &lt; <span class="number">0</span> || j - <span class="number">1</span> &lt; <span class="number">0</span> ) ? <span class="number">0</span>:  dp[i<span class="number">-1</span>][j<span class="number">-1</span>]);</span><br><span class="line">                    result = max(result, dp[i][j]);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-64-Minimum-Path-Sum"><a href="#4-Leetcode-64-Minimum-Path-Sum" class="headerlink" title="4. Leetcode 64. Minimum Path Sum"></a>4. <a href="https://leetcode.com/problems/minimum-path-sum/description/" target="_blank" rel="noopener">Leetcode 64. Minimum Path Sum</a></h4><p>Given a m x n grid filled with non-negative numbers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.</p><p>Note: You can only move either down or right at any point in time.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minPathSum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;      </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, INT_MAX));</span><br><span class="line">        dp[m][n<span class="number">-1</span>] = <span class="number">0</span>; dp[m<span class="number">-1</span>][n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>; i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n<span class="number">-1</span>;j &gt;=<span class="number">0</span>; j--)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i][j] = grid[i][j] + min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-688-Knight-Probability-in-chessboard"><a href="#5-Leetcode-688-Knight-Probability-in-chessboard" class="headerlink" title="5.Leetcode 688. Knight Probability in chessboard"></a>5.<a href="https://leetcode.com/problems/knight-probability-in-chessboard/description/" target="_blank" rel="noopener">Leetcode 688. Knight Probability in chessboard</a></h4><p>On an NxN chessboard, a knight starts at the r-th row and c-th column and attempts to make exactly K moves. The rows and columns are 0 indexed, so the top-left square is (0, 0), and the bottom-right square is (N-1, N-1).</p><p>A chess knight has 8 possible moves it can make, as illustrated below. Each move is two squares in a cardinal direction, then one square in an orthogonal direction.</p><p>Each time the knight is to move, it chooses one of eight possible moves uniformly at random (even if the piece would go off the chessboard) and moves there.</p><p>The knight continues moving until it has made exactly K moves or has moved off the chessboard. Return the probability that the knight remains on the board after it has stopped moving.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">double</span> <span class="title">knightProbability</span><span class="params">(<span class="keyword">int</span> N, <span class="keyword">int</span> K, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(r &gt;= N || c &gt;= N || r &lt; <span class="number">0</span> || c &lt; <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(K &lt;= <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1.0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="built_in">string</span> s = to_string(K) + <span class="string">","</span> + to_string(r) + <span class="string">","</span> + to_string(c);</span><br><span class="line">        <span class="keyword">if</span>(memo.count(s) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[s];</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">double</span> prob = <span class="number">1.0</span> / <span class="number">8.0</span>;</span><br><span class="line">        memo[s] =  prob * (                             knightProbability(N, K - <span class="number">1</span>, r - <span class="number">2</span>, c + <span class="number">1</span>) +            knightProbability(N, K - <span class="number">1</span>, r - <span class="number">2</span>, c - <span class="number">1</span>) +            knightProbability(N, K - <span class="number">1</span>, r - <span class="number">1</span>, c - <span class="number">2</span>) +            knightProbability(N, K - <span class="number">1</span>, r - <span class="number">1</span>, c + <span class="number">2</span>) +            knightProbability(N, K - <span class="number">1</span>, r + <span class="number">1</span>, c - <span class="number">2</span>) +            knightProbability(N, K - <span class="number">1</span>, r + <span class="number">1</span>, c + <span class="number">2</span>) +            knightProbability(N, K - <span class="number">1</span>, r + <span class="number">2</span>, c + <span class="number">1</span>) +            knightProbability(N, K - <span class="number">1</span>, r + <span class="number">2</span>, c - <span class="number">1</span>));</span><br><span class="line">        <span class="keyword">return</span> memo[s];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="keyword">double</span>&gt; memo;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-764-Largest-Plus-Sign"><a href="#6-Leetcode-764-Largest-Plus-Sign" class="headerlink" title="6.Leetcode 764. Largest Plus Sign"></a>6.<a href="https://leetcode.com/problems/largest-plus-sign/description/" target="_blank" rel="noopener">Leetcode 764. Largest Plus Sign</a></h4><p>In a 2D grid from (0, 0) to (N-1, N-1), every cell contains a 1, except those cells in the given list mines which are 0. What is the largest axis-aligned plus sign of 1s contained in the grid? Return the order of the plus sign. If there is none, return 0.</p><p>An “axis-aligned plus sign of 1s of order k” has some center grid[x][y] = 1 along with 4 arms of length k-1 going up, down, left, and right, and made of 1s. This is demonstrated in the diagrams below. Note that there could be 0s or 1s beyond the arms of the plus sign, only the relevant area of the plus sign is checked for 1s.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">orderOfLargestPlusSign</span><span class="params">(<span class="keyword">int</span> N, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; mines)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; grid(N, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(N, INT_MAX));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pos : mines)</span><br><span class="line">            grid[pos[<span class="number">0</span>]][pos[<span class="number">1</span>]] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>, k = N <span class="number">-1</span>, l = <span class="number">0</span>, r = <span class="number">0</span>, u = <span class="number">0</span>, d = <span class="number">0</span>; j &lt; N; j++, k--)</span><br><span class="line">            &#123;</span><br><span class="line">                grid[i][j] = min(grid[i][j], l = (grid[i][j] != <span class="number">0</span> ? <span class="number">1</span> + l : <span class="number">0</span>));</span><br><span class="line">                grid[i][k] = min(grid[i][k], r = (grid[i][k] != <span class="number">0</span> ? <span class="number">1</span> + r : <span class="number">0</span>));</span><br><span class="line">                grid[j][i] = min(grid[j][i], u = (grid[j][i] != <span class="number">0</span> ? <span class="number">1</span> + u : <span class="number">0</span>));</span><br><span class="line">                grid[k][i] = min(grid[k][i], d = (grid[k][i] != <span class="number">0</span> ? <span class="number">1</span> + d : <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> res= <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; N ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; N;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                res = max(res, grid[i][j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 9</title>
    <link href="https://gorillasx.github.io/2018/06/27/Preparing-For-Interview-Day-9/"/>
    <id>https://gorillasx.github.io/2018/06/27/Preparing-For-Interview-Day-9/</id>
    <published>2018-06-27T13:46:49.000Z</published>
    <updated>2018-06-27T22:00:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Review"><a href="#1-Review" class="headerlink" title="1. Review"></a>1. Review</h3><h4 id="1-Leetcode-726-Number-of-Atoms"><a href="#1-Leetcode-726-Number-of-Atoms" class="headerlink" title="1. Leetcode 726. Number of Atoms"></a>1. <a href="https://leetcode.com/problems/number-of-atoms/description/" target="_blank" rel="noopener">Leetcode 726. Number of Atoms</a></h4><p>Given a chemical formula (given as a string), return the count of each atom.</p><p>An atomic element always starts with an uppercase character, then zero or more lowercase letters, representing the name.</p><p>1 or more digits representing the count of that element may follow if the count is greater than 1. If the count is 1, no digits will follow. For example, H2O and H2O2 are possible, but H1O2 is impossible.</p><p>Two formulas concatenated together produce another formula. For example, H2O2He3Mg4 is also a formula.</p><p>A formula placed in parentheses, and a count (optionally added) is also a formula. For example, (H2O2) and (H2O2)3 are formulas.</p><p>Given a formula, output the count of all elements as a string in the following form: the first name (in sorted order), followed by its count (if that count is more than 1), followed by the second name (in sorted order), followed by its count (if that count is more than 1), and so on.</p><p>Example 1:<br>Input:<br>formula = “H2O”<br>Output: “H2O”<br>Explanation:<br>The count of elements are {‘H’: 2, ‘O’: 1}.<br>Example 2:<br>Input:<br>formula = “Mg(OH)2”<br>Output: “H2MgO2”<br>Explanation:<br>The count of elements are {‘H’: 2, ‘Mg’: 1, ‘O’: 2}.<br>Example 3:<br>Input:<br>formula = “K4(ON(SO3)2)2”<br>Output: “K4N2O14S4”<br>Explanation:<br>The count of elements are {‘K’: 4, ‘N’: 2, ‘O’: 14, ‘S’: 4}.</p><p><strong>Thoughts:</strong><br>Classical Stack problem </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">countOfAtoms</span><span class="params">(<span class="built_in">string</span> formula)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">stack</span>&lt;<span class="keyword">int</span>&gt; previous;</span><br><span class="line">        <span class="built_in">vector</span>&lt;pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt;&gt; Atoms;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; formula.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(formula[i] == <span class="string">'('</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                previous.push(Atoms.size());</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(formula[i] == <span class="string">')'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="keyword">int</span> value = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; formula.size() &amp;&amp; <span class="built_in">isdigit</span>(formula[i]))</span><br><span class="line">                &#123;</span><br><span class="line">                    value = value * <span class="number">10</span> + formula[i] - <span class="string">'0'</span>;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">int</span> start = previous.top(); previous.pop();</span><br><span class="line">                <span class="keyword">for</span>(;start &lt; Atoms.size();start++)</span><br><span class="line">                &#123;</span><br><span class="line">                    Atoms[start].second *= value;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> name = <span class="string">""</span>;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">while</span>(i &lt; formula.size() &amp;&amp; formula[i] != <span class="string">'('</span> &amp;&amp; formula[i] != <span class="string">')'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(formula[i] &gt;= <span class="string">'a'</span> &amp;&amp; formula[i] &lt;= <span class="string">'z'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        name += formula[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(formula[i] &gt;= <span class="string">'A'</span> &amp;&amp; formula[i] &lt;= <span class="string">'Z'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(name != <span class="string">""</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            Atoms.push_back(make_pair(name, count ? count : <span class="number">1</span>));</span><br><span class="line">                            name = <span class="string">""</span>;</span><br><span class="line">                            count = <span class="number">0</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        name += formula[i];</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">isdigit</span>(formula[i]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        count = count * <span class="number">10</span> + formula[i] - <span class="string">'0'</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    i++;</span><br><span class="line">                &#125;</span><br><span class="line">                i--;</span><br><span class="line">                <span class="keyword">if</span>(name != <span class="string">""</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Atoms.push_back(make_pair(name, count ? count : <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; atom;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; Atoms.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            atom[Atoms[i].first] += Atoms[i].second;</span><br><span class="line">        &#125;</span><br><span class="line">        Atoms.clear();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : atom)</span><br><span class="line">            Atoms.push_back(ele);</span><br><span class="line">        sort(Atoms.begin(), Atoms.end(),[](pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; lhs, pair&lt;<span class="built_in">string</span>,<span class="keyword">int</span>&gt; rhs)&#123;<span class="keyword">return</span> lhs.first &lt; rhs.first;&#125;);</span><br><span class="line">        <span class="built_in">string</span> result= <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele : Atoms)</span><br><span class="line">            result += (ele.first + (ele.second &gt; <span class="number">1</span> ?to_string(ele.second) : <span class="string">""</span>));</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-471-Encode-String-With-Shortest-Length"><a href="#2-Leetcode-471-Encode-String-With-Shortest-Length" class="headerlink" title="2. Leetcode 471. Encode String With Shortest Length"></a>2. <a href="https://leetcode.com/problems/encode-string-with-shortest-length/description/" target="_blank" rel="noopener">Leetcode 471. Encode String With Shortest Length</a></h4><p>Given a non-empty string, encode the string such that its encoded length is the shortest.</p><p>The encoding rule is: k[encoded_string], where the encoded_string inside the square brackets is being repeated exactly k times.</p><p>Note:</p><ol><li>k will be a positive integer and encoded string will not be empty or have extra space.</li><li>You may assume that the input string contains only lowercase English letters. The string’s length is at most 160.</li><li>If an encoding process does not make the string shorter, then do not encode it. If there are several solutions, return any of them is fine.<br>Example 1:</li></ol><p>Input: “aaa”<br>Output: “aaa”<br>Explanation: There is no way to encode it such that it is shorter than the input string, so we do not encode it.<br>Example 2:</p><p>Input: “aaaaa”<br>Output: “5[a]”<br>Explanation: “5[a]” is shorter than “aaaaa” by 1 character.</p><p><strong>Thoughts:</strong><br>Group same substring together, start with index 0. Check every possible length, then we break big problem to small problem. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">encode</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(shortest.count(s) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> shortest[s];</span><br><span class="line">        <span class="keyword">if</span>(s.size() &lt;= <span class="number">3</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">string</span> result = s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> len = <span class="number">1</span>; len &lt;= (s.size() / <span class="number">2</span>);len++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> source = s.substr(<span class="number">0</span>,len);</span><br><span class="line">            <span class="built_in">string</span> tmp = encode(source);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span>(s.substr(start, len) == source)</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                start += len;</span><br><span class="line">                <span class="built_in">string</span> ss = (count == <span class="number">1</span> ? tmp : to_string(count) + <span class="string">"["</span>+ tmp+ <span class="string">"]"</span>) + encode(s.substr(start));</span><br><span class="line">                result = (ss.size() &lt;= result.size() ? ss : result);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        shortest[s] = result;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; shortest;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-768-Max-Chunks-To-Make-Sorted-2"><a href="#3-Leetcode-768-Max-Chunks-To-Make-Sorted-2" class="headerlink" title="3. Leetcode 768. Max Chunks To Make Sorted 2"></a>3. <a href="https://leetcode.com/problems/max-chunks-to-make-sorted-ii/description/" target="_blank" rel="noopener">Leetcode 768. Max Chunks To Make Sorted 2</a></h4><p>This question is the same as “Max Chunks to Make Sorted” except the integers of the given array are not necessarily distinct, the input array could be up to length 2000, and the elements could be up to 10**8.</p><p>Given an array arr of integers (not necessarily distinct), we split the array into some number of “chunks” (partitions), and individually sort each chunk.  After concatenating them, the result equals the sorted array.</p><p>What is the most number of chunks we could have made?</p><p>Example 1:</p><p>Input: arr = [5,4,3,2,1]<br>Output: 1<br>Explanation:<br>Splitting into two or more chunks will not return the required result.<br>For example, splitting into [5, 4], [3, 2, 1] will result in [4, 5, 1, 2, 3], which isn’t sorted.<br>Example 2:</p><p>Input: arr = [2,1,3,4,4]<br>Output: 4<br>We can split into two chunks, such as [2, 1], [3, 4, 4].<br>However, splitting into [2, 1], [3], [4], [4] is the highest number of chunks possible.<br>Note:</p><p>arr will have length in range [1, 2000].<br>arr[i] will be an integer in range [0, 10**8].</p><p><strong>Thought:</strong><br>If a chunk in a right place, then smallest number in this chunk should larger than the previous chunk maximum number, largest number in this chunk should smaller than the minimum number in the next chunk.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxChunksToSorted</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; arr)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; small(arr.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> smallest = INT_MAX;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = arr.size()<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            small[i] = smallest;</span><br><span class="line">            smallest = min(smallest, arr[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> largest = INT_MIN, count = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; arr.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            largest = max(largest, arr[i]);</span><br><span class="line">            <span class="keyword">if</span>(largest &lt;= small[i])</span><br><span class="line">                count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-159-Longest-Substring-with-At-most-two-Distance-Characters"><a href="#4-Leetcode-159-Longest-Substring-with-At-most-two-Distance-Characters" class="headerlink" title="4. Leetcode 159. Longest Substring with At most two Distance Characters"></a>4. <a href="https://leetcode.com/problems/longest-substring-with-at-most-two-distinct-characters/description/" target="_blank" rel="noopener">Leetcode 159. Longest Substring with At most two Distance Characters</a></h4><p>Given a string s , find the length of the longest substring t  that contains at most 2 distinct characters.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLongestSubstringTwoDistinct</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>, end = <span class="number">0</span>, result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="keyword">int</span>&gt; counts;</span><br><span class="line">        <span class="keyword">for</span>(; end &lt; s.size(); end++)</span><br><span class="line">        &#123;</span><br><span class="line">            counts[s[end]]++;</span><br><span class="line">            <span class="keyword">while</span>(counts.size() &gt; <span class="number">2</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                counts[s[start]]--;</span><br><span class="line">                <span class="keyword">if</span>(counts[s[start]] == <span class="number">0</span>)</span><br><span class="line">                    counts.erase(s[start]);</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            result = max(result, end - start + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-425-Word-Squares"><a href="#5-Leetcode-425-Word-Squares" class="headerlink" title="5. Leetcode 425. Word Squares"></a>5. <a href="https://leetcode.com/problems/word-squares/description/" target="_blank" rel="noopener">Leetcode 425. Word Squares</a></h4><p>Given a set of words (without duplicates), find all word squares you can build from them.</p><p>A sequence of words forms a valid word square if the kth row and column read the exact same string, where 0 ≤ k &lt; max(numRows, numColumns).</p><p>For example, the word sequence [“ball”,”area”,”lead”,”lady”] forms a word square because each word reads the same both horizontally and vertically.</p><p>b a l l<br>a r e a<br>l e a d<br>l a d y<br>Note:<br>There are at least 1 and at most 1000 words.<br>All words will have the exact same length.<br>Word length is at least 1 and at most 5.<br>Each word contains only lowercase English alphabet a-z.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; wordSquares(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groups;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> word : words)</span><br><span class="line">            &#123;</span><br><span class="line">                groups[word[<span class="number">0</span>]].push_back(word);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; results;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> word : words)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.push_back(word);</span><br><span class="line">                backtracking(cur, groups, results);</span><br><span class="line">                cur.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">backtracking</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; cur, <span class="built_in">unordered_map</span>&lt;<span class="keyword">char</span>, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; groups, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">        </span>&#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.size() == cur[<span class="number">0</span>].size())</span><br><span class="line">                result.push_back(cur);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> index = cur.size();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> next : groups[cur[<span class="number">0</span>][cur.size()]])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; cur.size();i++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(next[i] != cur[i][index])</span><br><span class="line">                        &#123;</span><br><span class="line">                           <span class="keyword">break</span>; </span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(i == cur.size())</span><br><span class="line">                    &#123;</span><br><span class="line">                        cur.push_back(next);</span><br><span class="line">                        backtracking(cur, groups, result);</span><br><span class="line">                        cur.pop_back();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-Maximum-Sum-of-3-Non-Overlapping-Subarrays"><a href="#6-Leetcode-Maximum-Sum-of-3-Non-Overlapping-Subarrays" class="headerlink" title="6. Leetcode Maximum Sum of 3 Non-Overlapping Subarrays"></a>6. <a href="https://leetcode.com/problems/maximum-sum-of-3-non-overlapping-subarrays/description/" target="_blank" rel="noopener">Leetcode Maximum Sum of 3 Non-Overlapping Subarrays</a></h4><p>In a given array nums of positive integers, find three non-overlapping subarrays with maximum sum.</p><p>Each subarray will be of size k, and we want to maximize the sum of all 3*k entries.</p><p>Return the result as a list of indices representing the starting position of each interval (0-indexed). If there are multiple answers, return the lexicographically smallest one.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; maxSumOfThreeSubarrays(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ksums(nums.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sum += nums[i];</span><br><span class="line">            <span class="keyword">if</span>(i == k <span class="number">-1</span>)</span><br><span class="line">                ksums[i] = sum;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(i &gt; k<span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                sum -= nums[i-k];</span><br><span class="line">                ksums[i] = sum;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; dp(<span class="number">3</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;(nums.size(),make_pair(<span class="number">0</span>, <span class="number">0</span>)));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ;i &lt; <span class="number">3</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = (i + <span class="number">1</span>)* k - <span class="number">1</span>;j &lt; nums.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(j<span class="number">-1</span> &lt; <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[<span class="number">0</span>][j] = make_pair(ksums[j],j);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(ksums[j] &gt; dp[<span class="number">0</span>][j<span class="number">-1</span>].first)</span><br><span class="line">                            dp[<span class="number">0</span>][j] = make_pair(ksums[j], j);</span><br><span class="line">                        <span class="keyword">else</span> </span><br><span class="line">                            dp[<span class="number">0</span>][j] = dp[<span class="number">0</span>][j<span class="number">-1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(ksums[j] + dp[i<span class="number">-1</span>][j-k].first &gt; dp[i][j<span class="number">-1</span>].first)</span><br><span class="line">                        dp[i][j] = make_pair(ksums[j] + dp[i<span class="number">-1</span>][j-k].first, j);</span><br><span class="line">                    <span class="keyword">else</span> </span><br><span class="line">                        dp[i][j] = dp[i][j<span class="number">-1</span>];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        res[<span class="number">2</span>] = dp[<span class="number">2</span>][nums.size()<span class="number">-1</span>].second ;</span><br><span class="line">        res[<span class="number">1</span>] = dp[<span class="number">1</span>][res[<span class="number">2</span>] -k].second ;</span><br><span class="line">        res[<span class="number">0</span>] = dp[<span class="number">0</span>][res[<span class="number">1</span>] - k].second  ;</span><br><span class="line">        res[<span class="number">2</span>] = res[<span class="number">2</span>] - k + <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">1</span>] = res[<span class="number">1</span>] - k + <span class="number">1</span>;</span><br><span class="line">        res[<span class="number">0</span>] = res[<span class="number">0</span>] - k + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="7-Leetcode-753-Cracking-the-Safe"><a href="#7-Leetcode-753-Cracking-the-Safe" class="headerlink" title="7. Leetcode 753. Cracking the Safe"></a>7. <a href="https://leetcode.com/problems/cracking-the-safe/description/" target="_blank" rel="noopener">Leetcode 753. Cracking the Safe</a></h4><p>There is a box protected by a password. The password is n digits, where each letter can be one of the first k digits 0, 1, …, k-1.</p><p>You can keep inputting the password, the password will automatically be matched against the last n digits entered.</p><p>For example, assuming the password is “345”, I can open it when I type “012345”, but I enter a total of 6 digits.</p><p>Please return any string of minimum length that is guaranteed to open the box after the entire string is inputted.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>: <span class="function"><span class="built_in">string</span> <span class="title">crackSafe</span><span class="params">(<span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">string</span> cur = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">return</span> DFS(cur, n, k, visited);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">DFS</span><span class="params">(<span class="built_in">string</span> cur, <span class="keyword">int</span> n,<span class="keyword">int</span> k, <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt;&amp; visited)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(visited.size() == <span class="keyword">int</span>(<span class="built_in">pow</span>(k, n)))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> cur;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(cur.size() &lt; n <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cur.push_back(<span class="keyword">char</span>(i + <span class="string">'0'</span>));</span><br><span class="line">                <span class="built_in">string</span> res = DFS(cur, n, k, visited);</span><br><span class="line">                <span class="keyword">if</span>(res != <span class="string">""</span>)</span><br><span class="line">                    <span class="keyword">return</span> res; </span><br><span class="line">                cur.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> tmp = cur.substr(cur.size() - n + <span class="number">1</span>);</span><br><span class="line">                tmp += to_string(i);</span><br><span class="line">                <span class="keyword">if</span>(visited.count(tmp) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    cur.push_back(i + <span class="string">'0'</span>);</span><br><span class="line">                    visited.insert(tmp);</span><br><span class="line">                    <span class="built_in">string</span> res = DFS(cur, n, k, visited);</span><br><span class="line">                    <span class="keyword">if</span>(res != <span class="string">""</span>)</span><br><span class="line">                        <span class="keyword">return</span> res;</span><br><span class="line">                    cur.pop_back();</span><br><span class="line">                    visited.erase(tmp);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="8-Leetcode-668-Kth-Smallest-Number-in-Multiplication-Table"><a href="#8-Leetcode-668-Kth-Smallest-Number-in-Multiplication-Table" class="headerlink" title="8. Leetcode 668. Kth Smallest Number in Multiplication Table"></a>8. <a href="https://leetcode.com/problems/kth-smallest-number-in-multiplication-table/description/" target="_blank" rel="noopener">Leetcode 668. Kth Smallest Number in Multiplication Table</a></h4><p>Nearly every one have used the Multiplication Table. But could you find out the k-th smallest number quickly from the multiplication table?</p><p>Given the height m and the length n of a m * n Multiplication Table, and a positive integer k, you need to return the k-th smallest number in this table.</p><p>Example 1:<br>Input: m = 3, n = 3, k = 5<br>Output:<br>Explanation:<br>The Multiplication Table:<br>1    2    3<br>2    4    6<br>3    6    9</p><p>The 5-th smallest number is 3 (1, 2, 2, 3, 3).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findKthNumber</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> low = <span class="number">1</span>, high = m * n;</span><br><span class="line">        <span class="keyword">while</span>(low &lt; high)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (low + (high - low) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;=m ;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> div = mid / i;</span><br><span class="line">                <span class="keyword">if</span>(div &gt; n)</span><br><span class="line">                    count += n;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    count += div;</span><br><span class="line">                <span class="keyword">if</span>(div == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count &gt;= k)</span><br><span class="line">                high = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> low;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="9-Leetcode-272-Closest-Binary-Search-Tree-Value-2"><a href="#9-Leetcode-272-Closest-Binary-Search-Tree-Value-2" class="headerlink" title="9. Leetcode 272. Closest Binary Search Tree Value 2"></a>9. <a href="https://leetcode.com/problems/closest-binary-search-tree-value-ii/description/" target="_blank" rel="noopener">Leetcode 272. Closest Binary Search Tree Value 2</a></h4><p>Given a non-empty binary search tree and a target value, find k values in the BST that are closest to the target.</p><p>Note:</p><p>Given target value is a floating point.<br>You may assume k is always valid, that is: k ≤ total nodes.<br>You are guaranteed to have only one unique set of k values in the BST that are closest to the target.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; closestKValues(TreeNode* root, <span class="keyword">double</span> target, <span class="keyword">int</span> k)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; succ;</span><br><span class="line">        <span class="built_in">stack</span>&lt;TreeNode*&gt; prec;</span><br><span class="line">        createStack(succ, root, target, <span class="literal">true</span>);</span><br><span class="line">        createStack(prec, root, target, <span class="literal">false</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; k;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(succ.size() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = prec.top();</span><br><span class="line">                prec.pop();</span><br><span class="line">                result.push_back(tmp-&gt;val);</span><br><span class="line">                pushToStack(prec, tmp-&gt;left, <span class="literal">false</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(prec.size() == <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* tmp = succ.top();</span><br><span class="line">                succ.pop();</span><br><span class="line">                result.push_back(tmp-&gt;val);</span><br><span class="line">                pushToStack(succ, tmp-&gt;right, <span class="literal">true</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(<span class="keyword">double</span>(succ.top()-&gt;val) - target) &lt; <span class="built_in">abs</span>(<span class="keyword">double</span>(prec.top()-&gt;val) - target))</span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* tmp = succ.top();</span><br><span class="line">                    succ.pop();</span><br><span class="line">                    result.push_back(tmp-&gt;val);</span><br><span class="line">                    pushToStack(succ, tmp-&gt;right, <span class="literal">true</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    TreeNode* tmp = prec.top();</span><br><span class="line">                    prec.pop();</span><br><span class="line">                    result.push_back(tmp-&gt;val);</span><br><span class="line">                    pushToStack(prec, tmp-&gt;left, <span class="literal">false</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">createStack</span><span class="params">(<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; succ, TreeNode* root, <span class="keyword">double</span> target, <span class="keyword">bool</span> suc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(suc)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">double</span>(root-&gt;val) &gt;= target)</span><br><span class="line">                &#123;</span><br><span class="line">                    succ.push(root);</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(<span class="keyword">double</span>(root-&gt;val) &lt; target)</span><br><span class="line">                &#123;</span><br><span class="line">                    succ.push(root);</span><br><span class="line">                    root = root-&gt;right;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    root = root-&gt;left;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pushToStack</span><span class="params">(<span class="built_in">stack</span>&lt;TreeNode*&gt;&amp; succ, TreeNode* root, <span class="keyword">bool</span> suc)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            succ.push(root);</span><br><span class="line">            <span class="keyword">if</span>(suc)</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="10-Leetcode-847-Shortest-Path-Visiting-All-Nodes"><a href="#10-Leetcode-847-Shortest-Path-Visiting-All-Nodes" class="headerlink" title="10. Leetcode 847. Shortest Path Visiting All Nodes"></a>10. <a href="https://leetcode.com/problems/shortest-path-visiting-all-nodes/description/" target="_blank" rel="noopener">Leetcode 847. Shortest Path Visiting All Nodes</a></h4><p>An undirected, connected graph of N nodes (labeled 0, 1, 2, …, N-1) is given as graph.</p><p>graph.length = N, and j != i is in the list graph[i] exactly once, if and only if nodes i and j are connected.</p><p>Return the length of the shortest path that visits every node. You may start and stop at any node, you may revisit nodes multiple times, and you may reuse edges.<br>Example 1:</p><p>Input: [[1,2,3],[0],[0],[0]]<br>Output: 4<br>Explanation: One possible path is [1,0,2,0,3]</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">State</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">   <span class="keyword">int</span> cover;</span><br><span class="line">   <span class="keyword">int</span> cur;</span><br><span class="line">   State(<span class="keyword">int</span> cv, <span class="keyword">int</span> cr):cover(cv), cur(cr)&#123;&#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateHasher</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> State&amp; state) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span> * state.cover + (state.cover ^ state.cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">StateEqual</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> State&amp; statea, <span class="keyword">const</span> State&amp; stateb)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> statea.cover == stateb.cover &amp;&amp; statea.cur == stateb.cur;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">shortestPathLength</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; graph)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> numOfNode = graph.size();</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;State, StateHasher, StateEqual&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;State&gt; BFScurState;</span><br><span class="line">        <span class="comment">//Generate start state</span></span><br><span class="line">        <span class="keyword">int</span> target = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; numOfNode;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           target += (<span class="number">1</span> &lt;&lt; i);</span><br><span class="line">           <span class="function">State <span class="title">state</span><span class="params">(<span class="number">1</span> &lt;&lt; i, i)</span></span>; </span><br><span class="line">           visited.insert(state);</span><br><span class="line">           BFScurState.push(state);  </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!BFScurState.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = BFScurState.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                State tmp = BFScurState.front(); BFScurState.pop();</span><br><span class="line">                <span class="keyword">if</span>(tmp.cover == target)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> next : graph[tmp.cur])</span><br><span class="line">                &#123;</span><br><span class="line">                    State nextState(tmp.cover | (1 &lt;&lt; next), next);</span><br><span class="line">                    <span class="keyword">if</span>(visited.count(nextState) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited.insert(nextState);</span><br><span class="line">                        BFScurState.push(nextState);</span><br><span class="line">                    &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;        </span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="11-Leetcode-305-Number-Of-Islands-2"><a href="#11-Leetcode-305-Number-Of-Islands-2" class="headerlink" title="11. Leetcode 305. Number Of Islands 2"></a>11. <a href="https://leetcode.com/problems/number-of-islands-ii/description/" target="_blank" rel="noopener">Leetcode 305. Number Of Islands 2</a></h4><p>A 2d grid map of m rows and n columns is initially filled with water. We may perform an addLand operation which turns the water at position (row, col) into a land. Given a list of positions to operate, count the number of islands after each addLand operation. An island is surrounded by water and is formed by connecting adjacent lands horizontally or vertically. You may assume all four edges of the grid are all surrounded by water.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; numIslands2(<span class="keyword">int</span> m ,<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&amp; positions)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="built_in">array</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m * n;i++)</span><br><span class="line">            <span class="built_in">array</span>.push_back(i);</span><br><span class="line">        <span class="keyword">int</span> curN = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; islandSet;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> &amp; p : positions)</span><br><span class="line">        &#123;</span><br><span class="line">            curN++;</span><br><span class="line">            islandSet.insert(p.first * n + p.second);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = p.first + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = p.second + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; islandSet.count(r * n + c) == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> left = p.first * n + p.second;</span><br><span class="line">                    <span class="keyword">int</span> right = r * n + c;</span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">array</span>[left] != left)</span><br><span class="line">                        left = <span class="built_in">array</span>[left];</span><br><span class="line">                    <span class="keyword">while</span>(<span class="built_in">array</span>[right] != right)</span><br><span class="line">                        right = <span class="built_in">array</span>[right];</span><br><span class="line">                    <span class="keyword">if</span>(left != right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="built_in">array</span>[left] = right;</span><br><span class="line">                        curN--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            results.push_back(curN);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="12-Leetcode-465-Optimal-Account-Balancing"><a href="#12-Leetcode-465-Optimal-Account-Balancing" class="headerlink" title="12. Leetcode 465. Optimal Account Balancing"></a>12. <a href="https://leetcode.com/problems/optimal-account-balancing/description/" target="_blank" rel="noopener">Leetcode 465. Optimal Account Balancing</a></h4><p>A group of friends went on holiday and sometimes lent each other money. For example, Alice paid for Bill’s lunch for $10. Then later Chris gave Alice $5 for a taxi ride. We can model each transaction as a tuple (x, y, z) which means person x gave person y $z. Assuming Alice, Bill, and Chris are person 0, 1, and 2 respectively (0, 1, 2 are the person’s ID), the transactions can be represented as [[0, 1, 10], [2, 0, 5]].</p><p>Given a list of transactions between a group of people, return the minimum number of transactions required to settle the debt.</p><p>Note:</p><p>A transaction will be given as a tuple (x, y, z). Note that x ≠ y and z &gt; 0.<br>Person’s IDs may not be linear, e.g. we could have the persons 0, 1, 2 or we could also have the persons 0, 2, 6.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTransfers</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; transactions)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; balances;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> trans : transactions)</span><br><span class="line">        &#123;</span><br><span class="line">            balances[trans[<span class="number">0</span>]] -= trans[<span class="number">2</span>];</span><br><span class="line">            balances[trans[<span class="number">1</span>]] += trans[<span class="number">2</span>];</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; notBalance;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> ele: balances)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ele.second != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notBalance.push_back(ele.second);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(notBalance.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> step = INT_MAX;</span><br><span class="line">        DFS(notBalance, <span class="number">0</span>, <span class="number">0</span>, step);</span><br><span class="line">        <span class="keyword">return</span> step;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span>  <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; notBalance, <span class="keyword">int</span> index, <span class="keyword">int</span> step, <span class="keyword">int</span>&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index &lt; notBalance.size() &amp;&amp; notBalance[index] == <span class="number">0</span>)</span><br><span class="line">            index++; </span><br><span class="line">        <span class="keyword">if</span>(index == notBalance.size())</span><br><span class="line">        &#123;</span><br><span class="line">            result = min(result, step);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> balance = notBalance[index];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i  = index + <span class="number">1</span>; i &lt; notBalance.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(notBalance[i] * notBalance[index] &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                notBalance[i] += balance;</span><br><span class="line">                DFS(notBalance, index + <span class="number">1</span>, step + <span class="number">1</span>, result);</span><br><span class="line">                notBalance[i] -= balance;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Review&quot;&gt;&lt;a href=&quot;#1-Review&quot; class=&quot;headerlink&quot; title=&quot;1. Review&quot;&gt;&lt;/a&gt;1. Review&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-726-Number-of-Atoms&quot;&gt;&lt;a href
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 8</title>
    <link href="https://gorillasx.github.io/2018/06/26/Preparing-For-Interview-Day-8/"/>
    <id>https://gorillasx.github.io/2018/06/26/Preparing-For-Interview-Day-8/</id>
    <published>2018-06-26T13:26:49.000Z</published>
    <updated>2018-06-27T13:38:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-something-new"><a href="#1-something-new" class="headerlink" title="1. something new"></a>1. something new</h3><h4 id="1-Leetcode-392-IsSubsequence"><a href="#1-Leetcode-392-IsSubsequence" class="headerlink" title="1. Leetcode 392. IsSubsequence"></a>1. <a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">Leetcode 392. IsSubsequence</a></h4><p>Given two strings s1, s2, find the lowest ASCII sum of deleted characters to make two strings equal.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minimumDeleteSum</span><span class="params">(<span class="built_in">string</span> s1, <span class="built_in">string</span> s2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(s1.size()+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(s2.size() + <span class="number">1</span>, <span class="number">0</span>)); </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s2.size(); i++)</span><br><span class="line">            dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i<span class="number">-1</span>] + s2[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s1.size();i++)</span><br><span class="line">            dp[i][<span class="number">0</span>] = dp[i<span class="number">-1</span>][<span class="number">0</span>] + s1[i<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= s1.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= s2.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(s1[i<span class="number">-1</span>] == s2[j<span class="number">-1</span>])</span><br><span class="line">                    dp[i][j] = dp[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    dp[i][j] = min(<span class="keyword">int</span>(s1[i<span class="number">-1</span>]) + dp[i<span class="number">-1</span>][j], <span class="keyword">int</span>(s2[j<span class="number">-1</span>]) + dp[i][j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[s1.size()][s2.size()];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-454-4Sum-2"><a href="#2-Leetcode-454-4Sum-2" class="headerlink" title="2. Leetcode 454. 4Sum 2"></a>2. <a href="https://leetcode.com/problems/4sum-ii/description/" target="_blank" rel="noopener">Leetcode 454. 4Sum 2</a></h4><p>Given four lists A, B, C, D of integer values, compute how many tuples (i, j, k, l) there are such that A[i] + B[j] + C[k] + D[l] is zero.</p><p>To make problem a bit easier, all A, B, C, D have same length of N where 0 ≤ N ≤ 500. All integers are in the range of -228 to 228 - 1 and the result is guaranteed to be at most 231 - 1.</p><p><strong>Thought:</strong><br>The brute force solution is straight forward, we could try every possible combination, and count the combination that have sum equal to zero. The time complexity will be O(n<em>n</em>n<em>n). In order to improve the performance, we need to eliminate n terms as many as possible. If we already know the sum of three number from l1,l2, l3, then we don’t need to iterate through l4, we only need to search l4, to look how many target value it have. This can be done by using a hashmap to map the number to it’s count in l4. Then the time complexity will be improved to O(n</em>n<em>n). Because we know the length of each list smaller than 500. Then I’m thinking whether we can generate every possible combination of l3 and l4, then for every combination from l1 and l2, to find target in combination of l3 and l4. Then the time complexity will reduce to O(n</em>n<em>2) and the space we will need is O(n</em>n). </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">fourSumCount</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; B, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; C, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; D)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>,<span class="keyword">int</span>&gt; sumHave;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; C.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; D.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                sumHave[C[i] + D[j]]++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; A.size(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; B.size();j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">long</span> <span class="keyword">long</span>  target = <span class="number">0</span> - (A[i] + B[j]);</span><br><span class="line">                <span class="keyword">if</span>(sumHave.count(target) != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    count += sumHave[target];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-646-Maximum-Length-of-Pain-Chain"><a href="#3-Leetcode-646-Maximum-Length-of-Pain-Chain" class="headerlink" title="3. Leetcode 646. Maximum Length of Pain Chain"></a>3. <a href="https://leetcode.com/problems/maximum-length-of-pair-chain/description/" target="_blank" rel="noopener">Leetcode 646. Maximum Length of Pain Chain</a></h4><p>You are given n pairs of numbers. In every pair, the first number is always smaller than the second number.</p><p>Now, we define a pair (c, d) can follow another pair (a, b) if and only if b &lt; c. Chain of pairs can be formed in this fashion.</p><p>Given a set of pairs, find the length longest chain which can be formed. You needn’t use up all the given pairs. You can select pairs in any order.</p><p><strong>Thought:</strong><br>Classical Greedy algorithm(Interval Scheduling)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findLongestChain</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; pairs)</span> </span>&#123;</span><br><span class="line">        sort(pairs.begin(), pairs.end(), [](<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; lhs, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; rhs)&#123;<span class="keyword">return</span> lhs[<span class="number">1</span>] &lt; rhs[<span class="number">1</span>];&#125;);       </span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; pair;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; pairs.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i == <span class="number">0</span> || pairs[i][<span class="number">0</span>] &gt; pair[<span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                pair = pairs[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-343-Integer-Break"><a href="#4-Leetcode-343-Integer-Break" class="headerlink" title="4.Leetcode 343. Integer Break"></a>4.<a href="https://leetcode.com/problems/integer-break/description/" target="_blank" rel="noopener">Leetcode 343. Integer Break</a></h4><p>Given a positive integer n, break it into the sum of at least two positive integers and maximize the product of those integers. Return the maximum product you can get.</p><p>For example, given n = 2, return 1 (2 = 1 + 1); given n = 10, return 36 (10 = 3 + 3 + 4).</p><p>Note: You may assume that n is not less than 2 and not larger than 58.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">integerBreak</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n+<span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(n &lt;= <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(n == <span class="number">3</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>, dp[<span class="number">2</span>] = <span class="number">2</span>, dp[<span class="number">3</span>] = <span class="number">3</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">4</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = i;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt;= i - <span class="number">1</span>;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                dp[i] = max(dp[i], j * dp[i - j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-650-2-Keys-keyboard"><a href="#5-Leetcode-650-2-Keys-keyboard" class="headerlink" title="5. Leetcode 650. 2 Keys keyboard"></a>5. <a href="https://leetcode.com/problems/2-keys-keyboard/description/" target="_blank" rel="noopener">Leetcode 650. 2 Keys keyboard</a></h4><p>Initially on a notepad only one character ‘A’ is present. You can perform two operations on this notepad for each step:</p><p>Copy All: You can copy all the characters present on the notepad (partial copy is not allowed).<br>Paste: You can paste the characters which are copied last time.<br>Given a number n. You have to get exactly n ‘A’ on the notepad by performing the minimum number of steps permitted. Output the minimum number of steps to get n ‘A’.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSteps</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(n == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> minStep = n; </span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(n % i == <span class="number">0</span>)</span><br><span class="line">           &#123;</span><br><span class="line">              <span class="keyword">int</span> count = n / i; </span><br><span class="line">              minStep = min(minStep, count + minSteps(i));  </span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="keyword">return</span> minStep;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-392-Is-Subsequence"><a href="#6-Leetcode-392-Is-Subsequence" class="headerlink" title="6. Leetcode 392. Is Subsequence"></a>6. <a href="https://leetcode.com/problems/is-subsequence/description/" target="_blank" rel="noopener">Leetcode 392. Is Subsequence</a></h4><p>Given a string s and a string t, check if s is subsequence of t.</p><p>You may assume that there is only lower case English letters in both s and t. t is potentially a very long (length ~= 500,000) string, and s is a short string (&lt;=100).</p><p>A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, “ace” is a subsequence of “abcde” while “aec” is not).</p><p>Example 1:<br>s = “abc”, t = “ahbgdc”</p><p>Return true.</p><p>Example 2:<br>s = “axc”, t = “ahbgdc”</p><p>Return false.</p><p>Follow up:<br>If there are lots of incoming S, say S1, S2, … , Sk where k &gt;= 1B, and you want to check one by one to see if T has its subsequence. In this scenario, how would you change your code?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isSubsequence</span><span class="params">(<span class="built_in">string</span> s, <span class="built_in">string</span> t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> tindex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> sindex = <span class="number">0</span>; sindex &lt; s.size();sindex++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(tindex &lt; t.size() &amp;&amp;t[tindex] != s[sindex])</span><br><span class="line">                tindex++;</span><br><span class="line">            <span class="keyword">if</span>(tindex &gt;= t.size())</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            tindex++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-something-new&quot;&gt;&lt;a href=&quot;#1-something-new&quot; class=&quot;headerlink&quot; title=&quot;1. something new&quot;&gt;&lt;/a&gt;1. something new&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 7</title>
    <link href="https://gorillasx.github.io/2018/06/25/Preparing-For-Interview-Day-7/"/>
    <id>https://gorillasx.github.io/2018/06/25/Preparing-For-Interview-Day-7/</id>
    <published>2018-06-25T12:49:05.000Z</published>
    <updated>2018-06-25T15:51:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-695-Max-Area-Of-Islands"><a href="#1-Leetcode-695-Max-Area-Of-Islands" class="headerlink" title="1. Leetcode 695. Max Area Of Islands"></a>1. <a href="https://leetcode.com/problems/max-area-of-island/description/" target="_blank" rel="noopener">Leetcode 695. Max Area Of Islands</a></h4><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p><p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p><p>Example 1:<br>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]<br>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxAreaOfIsland</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span> ;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> maxArea = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span> &amp;&amp; visited[i][j] == <span class="literal">false</span>)</span><br><span class="line">               &#123;</span><br><span class="line">                  maxArea = max(maxArea, AreaOfIslands(grid, visited, m, n, i, j)); </span><br><span class="line">               &#125; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxArea; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">AreaOfIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> m, <span class="keyword">int</span> n, <span class="keyword">int</span> r, <span class="keyword">int</span> c)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(visited[r][c] == <span class="literal">true</span> <span class="keyword">or</span> grid[r][c] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">1</span>;</span><br><span class="line">       visited[r][c] = <span class="literal">true</span>; </span><br><span class="line">       <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">int</span> row = r + delta[i];</span><br><span class="line">           <span class="keyword">int</span> col = c + delta[i+<span class="number">1</span>];</span><br><span class="line">           <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; m &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; n)  </span><br><span class="line">           &#123;</span><br><span class="line">               count += AreaOfIslands(grid, visited, m, n, row, col);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;      </span><br><span class="line">       <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-110-Balanced-Binary-Tree"><a href="#2-Leetcode-110-Balanced-Binary-Tree" class="headerlink" title="2. Leetcode 110. Balanced Binary Tree"></a>2. <a href="https://leetcode.com/problems/balanced-binary-tree/description/" target="_blank" rel="noopener">Leetcode 110. Balanced Binary Tree</a></h4><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><p>a binary tree in which the depth of the two subtrees of every node never differ by more than 1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">        pair&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; result = isbalanced(root);</span><br><span class="line">        <span class="keyword">return</span> result.first;</span><br><span class="line">    &#125;</span><br><span class="line">    pair&lt;<span class="keyword">bool</span>, <span class="keyword">int</span>&gt; isbalanced(TreeNode* root)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> make_pair(<span class="literal">true</span>, <span class="number">0</span>);</span><br><span class="line">        pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt; leftResult = isbalanced(root-&gt;left);</span><br><span class="line">        pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt; rightResult = isbalanced(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span>(leftResult.first &amp;&amp; rightResult.first &amp;&amp; <span class="built_in">abs</span>(leftResult.second - rightResult.second) &lt;= <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> make_pair(<span class="literal">true</span>, max(leftResult.second, rightResult.second) + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> make_pair(<span class="literal">false</span>, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-366-Find-Leaves-Of-Binary-Tree"><a href="#3-Leetcode-366-Find-Leaves-Of-Binary-Tree" class="headerlink" title="3. Leetcode 366. Find Leaves Of Binary Tree"></a>3. <a href="https://leetcode.com/problems/find-leaves-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode 366. Find Leaves Of Binary Tree</a></h4><p>Given a binary tree, collect a tree’s nodes as if you were doing this: Collect and remove all leaves, repeat until the tree is empty.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">// Solution One: O(length * n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findLeaves(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="keyword">while</span>(root != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            FindAndRemove(root, cur);</span><br><span class="line">            results.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">FindAndRemove</span><span class="params">(TreeNode*&amp; node, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(node == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            cur.push_back(node-&gt;val);</span><br><span class="line">            node = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        FindAndRemove(node-&gt;left, cur);</span><br><span class="line">        FindAndRemove(node-&gt;right, cur);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two: O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findLeaves(TreeNode* root) &#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">       FindAndRemove(root, result);</span><br><span class="line">       <span class="keyword">return</span> result; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">FindAndRemove</span><span class="params">(TreeNode* &amp; root, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;root-&gt;val&#125;));</span><br><span class="line">            root == <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> left = FindAndRemove(root-&gt;left, result);</span><br><span class="line">        <span class="keyword">int</span> right = FindAndRemove(root-&gt;right, result);</span><br><span class="line">        <span class="keyword">int</span> level = max(left, right) + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(result.size() &lt; level + <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&#123;root-&gt;val&#125;);</span><br><span class="line">            <span class="keyword">return</span> level;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            result[level].push_back(root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-647-Palindromic-SubStrings"><a href="#4-Leetcode-647-Palindromic-SubStrings" class="headerlink" title="4. Leetcode 647. Palindromic SubStrings"></a>4. <a href="https://leetcode.com/problems/palindromic-substrings/description/" target="_blank" rel="noopener">Leetcode 647. Palindromic SubStrings</a></h4><p>Given a string, your task is to count how many palindromic substrings in this string.</p><p>The substrings with different start indexes or end indexes are counted as different substrings even they consist of same characters.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Brute Force Solution: O(n*n*n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(s.size(),<span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; s.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> start = i;start &gt;= <span class="number">0</span>;start--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(CheckPalid(s, start, i))</span><br><span class="line">                    dp[i]+=<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">        <span class="keyword">return</span> dp[s.size()<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">CheckPalid</span><span class="params">(<span class="built_in">string</span> s, <span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(s[start] != s[end])</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            start++;</span><br><span class="line">            end--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Solution Two: O(n2)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countSubstrings</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = s.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(len, <span class="literal">false</span>));</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= len; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; len + <span class="number">1</span> - l;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i, end = i + l - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(start == end <span class="keyword">or</span> (s[start] == s[end] &amp;&amp; (end - start == <span class="number">1</span> <span class="keyword">or</span> dp[start+<span class="number">1</span>][end<span class="number">-1</span>])))</span><br><span class="line">                &#123;</span><br><span class="line">                    count += <span class="number">1</span>;</span><br><span class="line">                    dp[start][end] = <span class="literal">true</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-413-Arithmetic-Slices"><a href="#5-Leetcode-413-Arithmetic-Slices" class="headerlink" title="5. Leetcode 413. Arithmetic Slices"></a>5. <a href="https://leetcode.com/problems/arithmetic-slices/description/" target="_blank" rel="noopener">Leetcode 413. Arithmetic Slices</a></h4><p>A sequence of number is called arithmetic if it consists of at least three elements and if the difference between any two consecutive elements is the same.</p><p>For example, these are arithmetic sequence:</p><p>1, 3, 5, 7, 9<br>7, 7, 7, 7<br>3, -1, -5, -9<br>The following sequence is not arithmetic.</p><p>1, 1, 2, 5, 7</p><p>A zero-indexed array A consisting of N numbers is given. A slice of that array is any pair of integers (P, Q) such that 0 &lt;= P &lt; Q &lt; N.</p><p>A slice (P, Q) of array A is called arithmetic if the sequence:<br>A[P], A[p + 1], …, A[Q - 1], A[Q] is arithmetic. In particular, this means that P + 1 &lt; Q.</p><p>The function should return the number of arithmetic slices in the array A.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution One </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(A.size()  &lt;= <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(start &lt; A.size() - <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(A[start+<span class="number">2</span>] - A[start+<span class="number">1</span>] == A[start+<span class="number">1</span>] - A[start])</span><br><span class="line">            &#123;</span><br><span class="line">                count++;</span><br><span class="line">                <span class="keyword">int</span> end = start + <span class="number">3</span>;</span><br><span class="line">                <span class="keyword">while</span>(end &lt; A.size() &amp;&amp; A[end] - A[end<span class="number">-1</span>] == A[end<span class="number">-1</span>] - A[end<span class="number">-2</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                    count += (end - start + <span class="number">1</span> - <span class="number">2</span>);</span><br><span class="line">                    end++;</span><br><span class="line">                &#125;</span><br><span class="line">                start = end - <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two : Memory Limit exceed</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numberOfArithmeticSlices</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> len = A.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt;&gt;&gt; dp(len, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">bool</span>,<span class="keyword">int</span>&gt;&gt;(len, make_pair(<span class="literal">false</span>, <span class="number">0</span>)));      </span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">2</span>; l &lt;= len; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len + <span class="number">1</span> - l;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i, end = i + l - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span>(l == <span class="number">2</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    dp[start][end] = make_pair(<span class="literal">true</span>, A[end] - A[start]);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[start+<span class="number">1</span>][end].first &amp;&amp; A[start+<span class="number">1</span>] - A[start] == dp[start+<span class="number">1</span>][end].second)</span><br><span class="line">                    &#123;</span><br><span class="line">                        count++;</span><br><span class="line">                        dp[start][end] = make_pair(<span class="literal">true</span>, dp[start+<span class="number">1</span>][end].second);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-364-Nested-List-Weight-Sum-2"><a href="#6-Leetcode-364-Nested-List-Weight-Sum-2" class="headerlink" title="6. Leetcode 364. Nested List Weight Sum 2"></a>6. <a href="https://leetcode.com/problems/nested-list-weight-sum-ii/description/" target="_blank" rel="noopener">Leetcode 364. Nested List Weight Sum 2</a></h4><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.</p><p>Each element is either an integer, or a list – whose elements may also be integers or other lists.</p><p>Different from the previous question where weight is increasing from root to leaf, now the weight is defined from bottom up. i.e., the leaf level integers have weight 1, and the root level integers have the largest weight.</p><p>Example 1:<br>Given the list [[1,1],2,[1,1]], return 8. (four 1’s at depth 1, one 2 at depth 2)</p><p>Example 2:<br>Given the list [1,[4,[6]]], return 17. (one 1 at depth 3, one 4 at depth 2, and one 6 at depth 1; 1<em>3 + 4</em>2 + 6*1 = 17)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSumInverse</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = GetDepth(nestedList);</span><br><span class="line">        <span class="keyword">return</span> calculate(nestedList, depth);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">GetDepth</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> depth = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nestedList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nestedList[i].isInteger() == <span class="literal">false</span>)</span><br><span class="line">                depth = max(depth, GetDepth(nestedList[i].getList()));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> depth + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculate</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> weight)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nestedList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nestedList[i].isInteger())</span><br><span class="line">                sum += (nestedList[i].getInteger() * weight);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                sum += calculate(nestedList[i].getList(), weight - <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 6</title>
    <link href="https://gorillasx.github.io/2018/06/24/Preparing-For-Interview-Day-6/"/>
    <id>https://gorillasx.github.io/2018/06/24/Preparing-For-Interview-Day-6/</id>
    <published>2018-06-24T20:09:10.000Z</published>
    <updated>2018-06-24T20:21:21.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-750-Number-Of-Corner-Rectangles"><a href="#1-Leetcode-750-Number-Of-Corner-Rectangles" class="headerlink" title="1. Leetcode 750. Number Of Corner Rectangles"></a>1. <a href="https://leetcode.com/problems/number-of-corner-rectangles/description/" target="_blank" rel="noopener">Leetcode 750. Number Of Corner Rectangles</a></h4><p>Given a grid where each entry is only 0 or 1, find the number of corner rectangles.</p><p>A corner rectangle is 4 distinct 1s on the grid that form an axis-aligned rectangle. Note that only the corners need to have the value 1. Also, all four 1s used must be distinct.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCornerRectangles</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; counts(m, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> bottomLeft = j - <span class="number">1</span>; bottomLeft &gt;= <span class="number">0</span>; bottomLeft--)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">if</span>(grid[i][bottomLeft] == <span class="number">1</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="keyword">for</span>(<span class="keyword">int</span> rightTop = i - <span class="number">1</span>; rightTop &gt;= <span class="number">0</span>; rightTop--)</span><br><span class="line">                            &#123;</span><br><span class="line">                                <span class="keyword">if</span>(grid[rightTop][j] == <span class="number">1</span> &amp;&amp; grid[rightTop][bottomLeft] == <span class="number">1</span>)</span><br><span class="line">                                &#123;</span><br><span class="line">                                    count++;</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125; </span><br><span class="line">                    &#125;        </span><br><span class="line">                &#125;</span><br><span class="line">                counts[i][j] = count + counts[i<span class="number">-1</span>][j] + counts[i][j<span class="number">-1</span>] - counts[i<span class="number">-1</span>][j<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> counts[m<span class="number">-1</span>][n<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-338-Counting-Bits"><a href="#2-Leetcode-338-Counting-Bits" class="headerlink" title="2. Leetcode 338. Counting Bits"></a>2. <a href="https://leetcode.com/problems/counting-bits/description/" target="_blank" rel="noopener">Leetcode 338. Counting Bits</a></h4><p>Given a non negative integer number num. For every numbers i in the range 0 ≤ i ≤ num calculate the number of 1’s in their binary representation and return them as an array.</p><p>Example:<br>For num = 5 you should return [0,1,1,2,1,2].</p><p>Follow up:</p><p>It is very easy to come up with a solution with run time O(n*sizeof(integer)). But can you do it in linear time O(n) /possibly in a single pass?<br>Space complexity should be O(n).<br>Can you do it like a boss? Do it without using any builtin function like __builtin_popcount in c++ or in any other language.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; countBits(<span class="keyword">int</span> num) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results(num+<span class="number">1</span>, <span class="number">0</span>);;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt;= num;i++)</span><br><span class="line">        &#123;</span><br><span class="line">           results[i] = results[i &amp; (i - <span class="number">1</span>)] + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-303-Range-Sum-Query-Immutable"><a href="#3-Leetcode-303-Range-Sum-Query-Immutable" class="headerlink" title="3. Leetcode 303. Range Sum Query - Immutable"></a>3. <a href="https://leetcode.com/problems/range-sum-query-immutable/description/" target="_blank" rel="noopener">Leetcode 303. Range Sum Query - Immutable</a></h4><p>Given an integer array nums, find the sum of the elements between indices i and j (i ≤ j), inclusive.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">NumArray</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    NumArray(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; nums) &#123;</span><br><span class="line">        sums = <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &gt;= <span class="number">1</span>)</span><br><span class="line">            sums[<span class="number">0</span>] = nums[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            sums[i] = sums[i<span class="number">-1</span>] + nums[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumRange</span><span class="params">(<span class="keyword">int</span> i, <span class="keyword">int</span> j)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> sums[j];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> sums[j] - sums[i<span class="number">-1</span>];</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; sums;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-70-Climbing-Stairs"><a href="#4-Leetcode-70-Climbing-Stairs" class="headerlink" title="4. Leetcode 70. Climbing Stairs"></a>4. <a href="https://leetcode.com/problems/climbing-stairs/description/" target="_blank" rel="noopener">Leetcode 70. Climbing Stairs</a></h4><p>You are climbing a stair case. It takes n steps to reach to the top.</p><p>Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?</p><p>Note: Given n will be a positive integer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">climbStairs</span><span class="params">(<span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; dp(n + <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line">        dp[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt;= n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-746-Min-Cost-Climbing-Stairs"><a href="#5-Leetcode-746-Min-Cost-Climbing-Stairs" class="headerlink" title="5. Leetcode 746. Min Cost Climbing Stairs"></a>5. <a href="https://leetcode.com/problems/min-cost-climbing-stairs/description/" target="_blank" rel="noopener">Leetcode 746. Min Cost Climbing Stairs</a></h4><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p><p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCostClimbingStairs</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cost)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = cost.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; minMemo(n, <span class="number">0</span>);</span><br><span class="line">        minMemo[<span class="number">0</span>] = cost[<span class="number">0</span>];</span><br><span class="line">        minMemo[<span class="number">1</span>] = cost[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">2</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            minMemo[i] = cost[i] + min(minMemo[i<span class="number">-1</span>], minMemo[i<span class="number">-2</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(minMemo[n<span class="number">-1</span>], minMemo[n<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-256-Paint-House"><a href="#6-Leetcode-256-Paint-House" class="headerlink" title="6. Leetcode 256. Paint House"></a>6. <a href="https://leetcode.com/problems/paint-house/description/" target="_blank" rel="noopener">Leetcode 256. Paint House</a></h4><p>There are a row of n houses, each house can be painted with one of the three colors: red, blue or green. The cost of painting each house with a certain color is different. You have to paint all the houses such that no two adjacent houses have the same color.</p><p>The cost of painting each house with a certain color is represented by a n x 3 cost matrix. For example, costs[0][0] is the cost of painting house 0 with color red; costs[1][2] is the cost of painting house 1 with color green, and so on… Find the minimum cost to paint all houses.</p><p>Note:<br>All costs are positive integers.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minCost</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; costs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(costs.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = costs.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(n, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(<span class="number">3</span>,<span class="number">0</span>));</span><br><span class="line">        dp[<span class="number">0</span>] = costs[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            dp[i][<span class="number">0</span>] = costs[i][<span class="number">0</span>] + min(dp[i<span class="number">-1</span>][<span class="number">1</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]);</span><br><span class="line">            dp[i][<span class="number">1</span>] = costs[i][<span class="number">1</span>] + min(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">2</span>]); </span><br><span class="line">            dp[i][<span class="number">2</span>] = costs[i][<span class="number">2</span>] + min(dp[i<span class="number">-1</span>][<span class="number">0</span>], dp[i<span class="number">-1</span>][<span class="number">1</span>]); </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> min(dp[n<span class="number">-1</span>][<span class="number">0</span>], min(dp[n<span class="number">-1</span>][<span class="number">1</span>], dp[n<span class="number">-1</span>][<span class="number">2</span>]));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 5</title>
    <link href="https://gorillasx.github.io/2018/06/23/Preparing-For-Interview-Day-5/"/>
    <id>https://gorillasx.github.io/2018/06/23/Preparing-For-Interview-Day-5/</id>
    <published>2018-06-23T18:51:34.000Z</published>
    <updated>2018-06-24T20:09:35.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-something-new"><a href="#1-something-new" class="headerlink" title="1. something new"></a>1. something new</h3><h4 id="1-Leetcode-752-Open-the-Lock"><a href="#1-Leetcode-752-Open-the-Lock" class="headerlink" title="1. Leetcode 752. Open the Lock"></a>1. <a href="https://leetcode.com/problems/open-the-lock/description/" target="_blank" rel="noopener">Leetcode 752. Open the Lock</a></h4><blockquote><p>You have a lock in front of you with 4 circular wheels. Each wheel has 10 slots: ‘0’, ‘1’, ‘2’, ‘3’, ‘4’, ‘5’, ‘6’, ‘7’, ‘8’, ‘9’. The wheels can rotate freely and wrap around: for example we can turn ‘9’ to be ‘0’, or ‘0’ to be ‘9’. Each move consists of turning one wheel one slot.<br>The lock initially starts at ‘0000’, a string representing the state of the 4 wheels.<br>You are given a list of deadends dead ends, meaning if the lock displays any of these codes, the wheels of the lock will stop turning and you will be unable to open it.<br>Given a target representing the value of the wheels that will unlock the lock, return the minimum total number of turns required to open the lock, or -1 if it is impossible.</p></blockquote><p><strong>Thought:</strong><br>For this problem, We want to find the minimum total number of turns, and each turns could have generate many different results, for this kind of question, usually, could be solved by using BFS. At each step, we generate all possible results, if target in those results, just return the current step. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">openLock</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; deadends, <span class="built_in">string</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; nextTry;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        visited.insert(<span class="string">"0000"</span>);</span><br><span class="line">        nextTry.push(<span class="string">"0000"</span>);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; dead;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> deadend : deadends)</span><br><span class="line">            dead.insert(deadend);</span><br><span class="line">        <span class="keyword">while</span>(!nextTry.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = nextTry.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> cur = nextTry.front(); nextTry.pop();</span><br><span class="line">                <span class="keyword">if</span>(dead.count(cur) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(cur == target)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> next = <span class="number">10</span> + cur[i] - <span class="string">'0'</span>;</span><br><span class="line">                    <span class="built_in">string</span> MinusOne = cur;</span><br><span class="line">                    MinusOne[i] = <span class="string">'0'</span> + (next - <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                    <span class="built_in">string</span> PlusOne = cur;</span><br><span class="line">                    PlusOne[i] = <span class="string">'0'</span> + (next + <span class="number">1</span>) % <span class="number">10</span>;</span><br><span class="line">                    <span class="keyword">if</span>(visited.count(MinusOne) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextTry.push(MinusOne);</span><br><span class="line">                        visited.insert(MinusOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(visited.count(PlusOne) == <span class="number">0</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        nextTry.push(PlusOne);</span><br><span class="line">                        visited.insert(PlusOne);</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-787-Cheapest-Flights-Within-K-Stops"><a href="#2-Leetcode-787-Cheapest-Flights-Within-K-Stops" class="headerlink" title="2.Leetcode 787. Cheapest Flights Within K Stops"></a>2.<a href="https://leetcode.com/problems/cheapest-flights-within-k-stops/description/" target="_blank" rel="noopener">Leetcode 787. Cheapest Flights Within K Stops</a></h4><blockquote><p>There are n cities connected by m flights. Each fight starts from city u and arrives at v with a price w.<br>Now given all the cities and fights, together with starting city src and the destination dst, your task is to find the cheapest price from src to dst with up to k stops. If there is no such route, output -1.</p></blockquote><p><strong>Thoughts:</strong><br>For this problem, we want to know the cheapest price with up to k stops. We can reach the destination with 0 stop, 1 stop, up to k stops. There are many different paths we can take to destination. And we want to know what’s the cheapest prices between those paths. we can use BFS to generate the city lists that we can reach from 0 zero to k stop. And we can know, what’s the minimum stop we need to get to destination. But, this doesn’t guarantee a cheapest price. Once we reach the destination, we use this price to update the cheapest price. If there is a path already cost more than the cheapest price, then we need to stop this path. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCheapestPrice</span><span class="params">(<span class="keyword">int</span> n, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; flights, <span class="keyword">int</span> src, <span class="keyword">int</span> dst, <span class="keyword">int</span> K)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt;&gt; flightsMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> flight : flights)</span><br><span class="line">            flightsMap[flight[<span class="number">0</span>]].emplace_back(flight[<span class="number">1</span>], flight[<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; nextCitys;</span><br><span class="line">        nextCitys.emplace(src, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">int</span> price = INT_MAX; <span class="keyword">bool</span> reach = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> flight = <span class="number">0</span>;flight &lt;= K;flight++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = nextCitys.size();</span><br><span class="line">            <span class="keyword">int</span> minPrices = INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> city = nextCitys.front(); nextCitys.pop();</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">auto</span> to : flightsMap[city.first])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(to.first == dst)</span><br><span class="line">                    &#123;</span><br><span class="line">                        reach = <span class="literal">true</span>;</span><br><span class="line">                        price = min(price, city.second + to.second);     </span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(visited.count(to.first) == <span class="number">0</span> <span class="keyword">or</span> (city.second + to.second &lt; visited[to.first]))</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[to.first] = city.second + to.second;</span><br><span class="line">                        nextCitys.emplace(to.first, visited[to.first]);</span><br><span class="line">                        minPrices = min(minPrices, visited[to.first]);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(reach &amp;&amp; minPrices &gt;= price)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> price;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reach)</span><br><span class="line">            <span class="keyword">return</span> price;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-773-Sliding-Puzzle"><a href="#3-Leetcode-773-Sliding-Puzzle" class="headerlink" title="3. Leetcode 773. Sliding Puzzle"></a>3. <a href="https://leetcode.com/problems/sliding-puzzle/description/" target="_blank" rel="noopener">Leetcode 773. Sliding Puzzle</a></h4><p>On a 2x3 board, there are 5 tiles represented by the integers 1 through 5, and an empty square represented by 0.</p><p>A move consists of choosing 0 and a 4-directionally adjacent number and swapping it.</p><p>The state of the board is solved if and only if the board is [[1,2,3],[4,5,0]].</p><p>Given a puzzle board, return the least number of moves required so that the state of the board is solved. If it is impossible for the state of the board to be solved, return -1.</p><p>Examples:</p><p>Input: board = [[1,2,3],[4,0,5]]<br>Output: 1<br>Explanation: Swap the 0 and the 5 in one move.<br>Input: board = [[1,2,3],[5,4,0]]<br>Output: -1<br>Explanation: No number of moves will make the board solved.<br>Input: board = [[4,1,2],[5,0,3]]<br>Output: 5<br>Explanation: 5 is the smallest number of moves that solves the board.<br>An example path:<br>After move 0: [[4,1,2],[5,0,3]]<br>After move 1: [[4,1,2],[0,5,3]]<br>After move 2: [[0,1,2],[4,5,3]]<br>After move 3: [[1,0,2],[4,5,3]]<br>After move 4: [[1,2,0],[4,5,3]]<br>After move 5: [[1,2,3],[4,5,0]]<br>Input: board = [[3,2,4],[1,5,0]]<br>Output: 14<br>Note:</p><p>board will be a 2 x 3 array as described above.<br>board[i][j] will be a permutation of [0, 1, 2, 3, 4, 5].</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">slidingPuzzle</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; moves = &#123;&#123;<span class="number">1</span>, <span class="number">3</span>&#125;, &#123;<span class="number">0</span>, <span class="number">2</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">5</span>&#125;, &#123;<span class="number">0</span>, <span class="number">4</span>&#125;, &#123;<span class="number">1</span>, <span class="number">3</span>, <span class="number">5</span>&#125;, &#123;<span class="number">2</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line">        <span class="built_in">string</span> source = to_string(board[<span class="number">0</span>][<span class="number">0</span>]) + to_string(board[<span class="number">0</span>][<span class="number">1</span>]) + to_string(board[<span class="number">0</span>][<span class="number">2</span>]) + to_string(board[<span class="number">1</span>][<span class="number">0</span>]) + to_string(board[<span class="number">1</span>][<span class="number">1</span>]) + to_string(board[<span class="number">1</span>][<span class="number">2</span>]);</span><br><span class="line">        <span class="built_in">string</span> target = <span class="string">"123450"</span>;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; states;</span><br><span class="line">        visited.insert(source);</span><br><span class="line">        states.push(source);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!states.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = states.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> cur = states.front(); states.pop();</span><br><span class="line">                <span class="keyword">if</span>(cur == target)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> zero = <span class="number">0</span>; zero &lt; <span class="number">6</span>;zero++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(cur[zero] == <span class="string">'0'</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">for</span>(<span class="keyword">int</span> move : moves[zero])</span><br><span class="line">                        &#123;</span><br><span class="line">                            <span class="built_in">string</span> tmp = cur;</span><br><span class="line">                            swap(tmp[zero], tmp[move]);</span><br><span class="line">                            <span class="keyword">if</span>(visited.count(tmp) == <span class="number">0</span>)</span><br><span class="line">                            &#123;</span><br><span class="line">                                visited.insert(tmp);</span><br><span class="line">                                states.push(tmp);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-301-Remove-Invalid-Parentheses"><a href="#4-Leetcode-301-Remove-Invalid-Parentheses" class="headerlink" title="4. Leetcode 301. Remove Invalid Parentheses"></a>4. <a href="https://leetcode.com/problems/remove-invalid-parentheses/description/" target="_blank" rel="noopener">Leetcode 301. Remove Invalid Parentheses</a></h4><p>Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; removeInvalidParentheses(<span class="built_in">string</span> s) &#123;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">string</span>&gt; states;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; visited;    </span><br><span class="line">        states.push(s); visited.insert(s);</span><br><span class="line">        <span class="keyword">while</span>(!states.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = states.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; results;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;  size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">string</span> cur = states.front(); states.pop();</span><br><span class="line">                <span class="keyword">if</span>(checkValid(cur))</span><br><span class="line">                    results.push_back(cur);         </span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>;index &lt; cur.size();index++)</span><br><span class="line">                   &#123;</span><br><span class="line">                       <span class="keyword">if</span>(cur[index] == <span class="string">')'</span> <span class="keyword">or</span> cur[index] == <span class="string">'('</span>)</span><br><span class="line">                       &#123;</span><br><span class="line">                           <span class="built_in">string</span> tmp = cur;</span><br><span class="line">                           tmp.erase(index, <span class="number">1</span>);</span><br><span class="line">                           <span class="keyword">if</span>(visited.count(tmp) == <span class="number">0</span>)</span><br><span class="line">                           &#123;</span><br><span class="line">                               visited.insert(tmp);</span><br><span class="line">                               states.push(tmp); </span><br><span class="line">                           &#125;  </span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(results.size() != <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> results;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">checkValid</span><span class="params">(<span class="built_in">string</span> s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">       <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i&lt; s.size();i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">if</span>(s[i] == <span class="string">'('</span>) count++;</span><br><span class="line">           <span class="keyword">else</span> <span class="keyword">if</span>(s[i] == <span class="string">')'</span>) count--;</span><br><span class="line">           <span class="keyword">if</span>(count &lt; <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">       &#125;  </span><br><span class="line">       <span class="keyword">return</span> count == <span class="number">0</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-499-The-Maze-3"><a href="#5-Leetcode-499-The-Maze-3" class="headerlink" title="5. Leetcode 499. The Maze 3"></a>5. <a href="https://leetcode.com/problems/the-maze-iii/description/" target="_blank" rel="noopener">Leetcode 499. The Maze 3</a></h4><p>There is a ball in a maze with empty spaces and walls. The ball can go through empty spaces by rolling up (u), down (d), left (l) or right (r), but it won’t stop rolling until hitting a wall. When the ball stops, it could choose the next direction. There is also a hole in this maze. The ball will drop into the hole if it rolls on to the hole.</p><p>Given the ball position, the hole position and the maze, find out how the ball could drop into the hole by moving the shortest distance. The distance is defined by the number of empty spaces traveled by the ball from the start position (excluded) to the hole (included). Output the moving directions by using ‘u’, ‘d’, ‘l’ and ‘r’. Since there could be several different shortest ways, you should output the lexicographically smallest way. If the ball cannot reach the hole, output “impossible”.</p><p>The maze is represented by a binary 2D array. 1 means the wall and 0 means the empty space. You may assume that the borders of the maze are all walls. The ball and the hole coordinates are represented by row and column indexes.</p><p><strong>Thought:</strong><br>If we want use user defined object as the key of unordered_set and unordered_map, we need to define haser function and equal_to function for the user defined object. The content that used to compute hash ID and compare, must same. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">state</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> row;</span><br><span class="line">    <span class="keyword">int</span> col;</span><br><span class="line">    <span class="keyword">int</span> distance;</span><br><span class="line">    <span class="built_in">string</span> path;</span><br><span class="line">    state(<span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> d, <span class="built_in">string</span> p):row(r), col(c), distance(d), path(p)&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">hasher</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">size_t</span> <span class="keyword">operator</span>()(<span class="keyword">const</span> state&amp; s)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        hash&lt;<span class="built_in">string</span>&gt; hasher;</span><br><span class="line">       <span class="keyword">return</span> s.row *<span class="number">123</span> + s.col * <span class="number">534</span>; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">equa</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> state&amp; l, <span class="keyword">const</span> state&amp; r)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> l.row == r.row &amp;&amp; l.col == r.col; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">findShortestWay</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; maze, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; ball, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; hole)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = maze.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? maze[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;state&gt; states;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;state, pair&lt;<span class="keyword">int</span>, <span class="built_in">string</span>&gt;, hasher, equa&gt; visited;</span><br><span class="line">        <span class="function">state <span class="title">start</span><span class="params">(ball[<span class="number">0</span>],ball[<span class="number">1</span>], <span class="number">0</span>, <span class="string">""</span>)</span></span>;</span><br><span class="line">        states.push(start);</span><br><span class="line">        visited[start] = make_pair(<span class="number">0</span>, <span class="string">""</span>);    </span><br><span class="line">        <span class="keyword">bool</span> reach = <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt; moves = &#123;<span class="string">'r'</span>, <span class="string">'d'</span>, <span class="string">'l'</span>, <span class="string">'u'</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> minStep = INT_MAX; <span class="built_in">string</span> minPath = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">while</span>(!states.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            state cur = states.front(); states.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">int</span> row = cur.row, col = cur.col;</span><br><span class="line">                <span class="keyword">bool</span> couldReach = <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">while</span>(row + delta[i] &gt;= <span class="number">0</span> &amp;&amp; row + delta[i] &lt; m &amp;&amp; col + delta[i+<span class="number">1</span>] &gt;= <span class="number">0</span> &amp;&amp; col + delta[i+<span class="number">1</span>] &lt; n &amp;&amp; maze[row + delta[i]][col + delta[i+<span class="number">1</span>]] == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                   row += delta[i];</span><br><span class="line">                   col += delta[i+<span class="number">1</span>];</span><br><span class="line">                   step++;</span><br><span class="line">                   <span class="keyword">if</span>(row == hole[<span class="number">0</span>] &amp;&amp; col == hole[<span class="number">1</span>])</span><br><span class="line">                   &#123;</span><br><span class="line">                       reach = <span class="literal">true</span>; </span><br><span class="line">                       couldReach = <span class="literal">true</span>;</span><br><span class="line">                       <span class="built_in">string</span> path = cur.path + moves[i]; </span><br><span class="line">                       <span class="keyword">if</span>(cur.distance + step &lt; minStep <span class="keyword">or</span> (cur.distance + step == minStep &amp;&amp; path &lt; minPath)) </span><br><span class="line">                       &#123;</span><br><span class="line">                           minStep = cur.distance + step;</span><br><span class="line">                           minPath = path; </span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(step == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="function">state <span class="title">next</span><span class="params">(row, col, cur.distance + step, cur.path + moves[i])</span></span>;</span><br><span class="line">                <span class="keyword">if</span>(reach == <span class="literal">false</span> <span class="keyword">or</span> (reach == <span class="literal">true</span> &amp;&amp; (next.distance &lt; minStep <span class="keyword">or</span> (next.distance == minStep &amp;&amp; next.path &lt; minPath))))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(visited.count(next) == <span class="number">0</span> <span class="keyword">or</span> (next.distance &lt; visited[next].first <span class="keyword">or</span> ( next.distance == visited[next].first &amp;&amp; next.path &lt; visited[next].second)))</span><br><span class="line">                    &#123;</span><br><span class="line">                        visited[next] = make_pair(next.distance, next.path);</span><br><span class="line">                        states.push(next);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(reach)</span><br><span class="line">            <span class="keyword">return</span> minPath;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"impossible"</span>;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-675-Cut-Off-Trees-for-Gold-Event"><a href="#6-Leetcode-675-Cut-Off-Trees-for-Gold-Event" class="headerlink" title="6. Leetcode 675. Cut Off Trees for Gold Event"></a>6. <a href="https://leetcode.com/problems/cut-off-trees-for-golf-event/description/" target="_blank" rel="noopener">Leetcode 675. Cut Off Trees for Gold Event</a></h4><p>You are asked to cut off trees in a forest for a golf event. The forest is represented as a non-negative 2D map, in this map:</p><p>0 represents the obstacle can’t be reached.<br>1 represents the ground can be walked through.<br>The place with number bigger than 1 represents a tree can be walked through, and this positive number represents the tree’s height.<br>You are asked to cut off all the trees in this forest in the order of tree’s height - always cut off the tree with lowest height first. And after cutting, the original place has the tree will become a grass (value 1).</p><p>You will start from the point (0, 0) and you should output the minimum steps you need to walk to cut off all the trees. If you can’t cut off all the trees, output -1 in that situation.</p><p>You are guaranteed that no two trees have the same height and there is at least one tree needs to be cut off.</p><p><strong>Thoughts:</strong><br>We are guaranteed that no two trees have the same height and we always need to cut off the tree with lowest height first. Therefore, the cut off order is fixed. We only need to know what’s the shortest distance from current position to the next position. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span><span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">cutOffTree</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest)</span> </span>&#123;</span><br><span class="line">          <span class="keyword">typedef</span> priority_queue&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, comp&gt; vectorpq; </span><br><span class="line">          vectorpq nextStep;</span><br><span class="line">          <span class="keyword">int</span> m = forest.size();</span><br><span class="line">          <span class="keyword">int</span> n = m ? forest[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">          &#123;</span><br><span class="line">              <span class="keyword">for</span>(<span class="keyword">int</span> j =<span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">              &#123;</span><br><span class="line">                  <span class="keyword">if</span>(forest[i][j] &gt; <span class="number">1</span>)</span><br><span class="line">                  &#123;</span><br><span class="line">                      nextStep.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;forest[i][j], i, j&#125;));</span><br><span class="line">                  &#125;</span><br><span class="line">              &#125;</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; start = &#123;<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>&#125;; </span><br><span class="line">          <span class="keyword">if</span>(nextStep.top()[<span class="number">1</span>] == <span class="number">0</span> &amp;&amp; nextStep.top()[<span class="number">2</span>] == <span class="number">0</span>)</span><br><span class="line">          &#123;</span><br><span class="line">             nextStep.pop(); </span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">int</span> totalStep = <span class="number">0</span>;</span><br><span class="line">          <span class="keyword">while</span>(!nextStep.empty())                    </span><br><span class="line">          &#123;</span><br><span class="line">              <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; next = nextStep.top(); nextStep.pop();</span><br><span class="line">              <span class="keyword">int</span> dis = ShortestDistance(forest, start[<span class="number">1</span>], start[<span class="number">2</span>], next[<span class="number">1</span>], next[<span class="number">2</span>]);</span><br><span class="line">              <span class="keyword">if</span>(dis == <span class="number">-1</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">              totalStep += dis;</span><br><span class="line">              swap(start, next);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">return</span> totalStep; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">ShortestDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; forest, <span class="keyword">int</span> sr, <span class="keyword">int</span> sc, <span class="keyword">int</span> dr, <span class="keyword">int</span> dc )</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = forest.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? forest[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; poss;</span><br><span class="line">        poss.emplace(sr,sc);</span><br><span class="line">        <span class="keyword">int</span> step = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        visited[sr][sc] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(!poss.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = poss.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> pos = poss.front(); poss.pop();</span><br><span class="line">                <span class="keyword">if</span>(pos.first == dr &amp;&amp; pos.second == dc)</span><br><span class="line">                    <span class="keyword">return</span> step;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> index = <span class="number">0</span>; index &lt; <span class="number">4</span>;index++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = pos.first + delta[index];</span><br><span class="line">                    <span class="keyword">int</span> c = pos.second + delta[index+<span class="number">1</span>];</span><br><span class="line">                    <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; forest[r][c] != <span class="number">0</span> &amp;&amp; visited[r][c] == <span class="literal">false</span>)</span><br><span class="line">                    &#123;</span><br><span class="line">                       visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                       poss.emplace(r, c);  </span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            step++;</span><br><span class="line">        &#125;    </span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-something-new&quot;&gt;&lt;a href=&quot;#1-something-new&quot; class=&quot;headerlink&quot; title=&quot;1. something new&quot;&gt;&lt;/a&gt;1. something new&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 4</title>
    <link href="https://gorillasx.github.io/2018/06/22/Preparing-For-Interview-Day-4/"/>
    <id>https://gorillasx.github.io/2018/06/22/Preparing-For-Interview-Day-4/</id>
    <published>2018-06-22T14:42:00.000Z</published>
    <updated>2018-06-23T02:14:59.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-130-Surrounded-Regions"><a href="#1-Leetcode-130-Surrounded-Regions" class="headerlink" title="1. Leetcode 130. Surrounded Regions"></a>1. <a href="https://leetcode.com/problems/surrounded-regions/description/" target="_blank" rel="noopener">Leetcode 130. Surrounded Regions</a></h4><p>Given a 2D board containing ‘X’ and ‘O’ (the letter O), capture all regions surrounded by ‘X’.</p><p>A region is captured by flipping all ‘O’s into ‘X’s in that surrounded region.</p><p>Example:</p><p>X X X X<br>X O O X<br>X X O X<br>X O X X<br>After running your function, the board should be:</p><p>X X X X<br>X X X X<br>X X X X<br>X O X X<br>Explanation:</p><p>Surrounded regions shouldn’t be on the border, which means that any ‘O’ on the border of the board are not flipped to ‘X’. Any ‘O’ that is not on the border and it is not connected to an ‘O’ on the border will be flipped to ‘X’. Two cells are connected if they are adjacent cells connected horizontally or vertically.</p><p><strong>Thought:</strong><br>Typical BFS problem.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">solve</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? board[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; zeros;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[<span class="number">0</span>][i] == <span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                board[<span class="number">0</span>][i] = <span class="string">'M'</span>;</span><br><span class="line">                zeros.emplace(<span class="number">0</span>,i);</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[m<span class="number">-1</span>][i] == <span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                board[m<span class="number">-1</span>][i] = <span class="string">'M'</span>;</span><br><span class="line">                zeros.emplace(m<span class="number">-1</span>, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt;m ;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(board[i][<span class="number">0</span>] == <span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                board[i][<span class="number">0</span>] = <span class="string">'M'</span>;</span><br><span class="line">                zeros.emplace(i, <span class="number">0</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(board[i][n<span class="number">-1</span>] == <span class="string">'O'</span>)</span><br><span class="line">            &#123;</span><br><span class="line">               board[i][n<span class="number">-1</span>] = <span class="string">'M'</span>;</span><br><span class="line">               zeros.emplace(i, n<span class="number">-1</span>);  </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!zeros.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">auto</span> pos = zeros.front(); zeros.pop();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = pos.first + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = pos.second + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; board[r][c] == <span class="string">'O'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[r][c] = <span class="string">'M'</span>;</span><br><span class="line">                    zeros.emplace(r, c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(board[i][j] == <span class="string">'O'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'X'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span>(board[i][j] == <span class="string">'M'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    board[i][j] = <span class="string">'O'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traverse"><a href="#2-Leetcode-103-Binary-Tree-Zigzag-Level-Order-Traverse" class="headerlink" title="2. Leetcode 103. Binary Tree Zigzag Level Order Traverse"></a>2. <a href="https://leetcode.com/problems/binary-tree-zigzag-level-order-traversal/description/" target="_blank" rel="noopener">Leetcode 103. Binary Tree Zigzag Level Order Traverse</a></h4><p>Given a binary tree, return the zigzag level order traversal of its nodes’ values. (ie, from left to right, then right to left for the next level and alternate between).</p><p><strong>Thought:</strong></p><ol><li>Level Order Traverse: It’s easy to achieve level order traverse with Queue + BFS, in order to achieve zigzag on each level, we want a data structure could support push_back, push_front, pop_back, pop_front, there are two type of data structure meed those requirements, list and deque. </li><li>ZigZag order: need a variable to record current state, and change it. </li></ol><blockquote><p>deque (usually pronounced like “deck”) is an irregular acronym of double-ended queue. Double-ended queues are sequence containers with dynamic sizes that can be expanded or contracted on both ends (either its front or its back).<br>Specific libraries may implement deques in different ways, generally as some form of dynamic array. But in any case, they allow for the individual elements to be accessed directly through random access iterators, with storage handled automatically by expanding and contracting the container as needed.<br>Therefore, they provide a functionality similar to vectors, but with efficient insertion and deletion of elements also at the beginning of the sequence, and not only at its end. But, unlike vectors, deques are not guaranteed to store all its elements in contiguous storage locations: accessing elements in a deque by offsetting a pointer to another element causes undefined behavior.<br>Both vectors and deques provide a very similar interface and can be used for similar purposes, but internally both work in quite different ways: While vectors use a single array that needs to be occasionally reallocated for growth, the elements of a deque can be scattered in different chunks of storage, with the container keeping the necessary information internally to provide direct access to any of its elements in constant time and with a uniform sequential interface (through iterators). Therefore, deques are a little more complex internally than vectors, but this allows them to grow more efficiently under certain circumstances, especially with very long sequences, where reallocations become more expensive.<br>For operations that involve frequent insertion or removals of elements at positions other than the beginning or the end, deques perform worse and have less consistent iterators and references than lists and forward lists.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; zigzagLevelOrder(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">        <span class="built_in">list</span>&lt;TreeNode*&gt; nodes;</span><br><span class="line">        <span class="keyword">bool</span> needTraverse = <span class="literal">false</span>;</span><br><span class="line">        nodes.push_back(root);</span><br><span class="line">        <span class="keyword">while</span>(!nodes.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = nodes.size();</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* root = needTraverse ? nodes.back() : nodes.front();</span><br><span class="line">                cur.push_back(root-&gt;val); </span><br><span class="line">                <span class="keyword">if</span>(needTraverse)</span><br><span class="line">                &#123;</span><br><span class="line">                    nodes.pop_back();</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                        nodes.push_front(root-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                        nodes.push_front(root-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                &#123;</span><br><span class="line">                    nodes.pop_front();</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">                        nodes.push_back(root-&gt;left);</span><br><span class="line">                    <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">                        nodes.push_back(root-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">            needTraverse = !needTraverse;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-62-Unique-Paths"><a href="#3-Leetcode-62-Unique-Paths" class="headerlink" title="3. Leetcode 62. Unique Paths"></a>3. <a href="https://leetcode.com/problems/unique-paths/description/" target="_blank" rel="noopener">Leetcode 62. Unique Paths</a></h4><p>A robot is located at the top-left corner of a m x n grid (marked ‘Start’ in the diagram below).</p><p>The robot can only move either down or right at any point in time. The robot is trying to reach the bottom-right corner of the grid (marked ‘Finish’ in the diagram below).</p><p>How many possible unique paths are there?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">uniquePaths</span><span class="params">(<span class="keyword">int</span> m, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(m + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        memo[m<span class="number">-1</span>][n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m<span class="number">-1</span>;i &gt;= <span class="number">0</span>;i-- )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n <span class="number">-1</span>; j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                memo[i][j] += memo[i+<span class="number">1</span>][j] + memo[i][j+<span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-714-Best-Time-To-Buy-And-Sell-Stock-With-Transaction-Fee"><a href="#4-Leetcode-714-Best-Time-To-Buy-And-Sell-Stock-With-Transaction-Fee" class="headerlink" title="4. Leetcode 714. Best Time To Buy And Sell Stock With Transaction Fee"></a>4. <a href="https://leetcode.com/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/description/" target="_blank" rel="noopener">Leetcode 714. Best Time To Buy And Sell Stock With Transaction Fee</a></h4><p>Your are given an array of integers prices, for which the i-th element is the price of a given stock on day i; and a non-negative integer fee representing a transaction fee.</p><p>You may complete as many transactions as you like, but you need to pay the transaction fee for each transaction. You may not buy more than 1 share of a stock at a time (ie. you must sell the stock share before you buy again.)</p><p>Return the maximum profit you can make.</p><p><strong>Thought:</strong><br>Each day have two states, hold a share of the stock, don’t have any stock. So every day, If I want to hold a share of stock, I want maximum profit when I sold it later. At every day, I have two ways to hold the stock, one is I alreay have this stock before, another is buying the stock at that day.  we need two variable to record the money we have earned and the price of the stock we have. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(prices.size() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> hold = <span class="number">0</span>, price = prices[<span class="number">0</span>], sell = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpsell = sell;</span><br><span class="line">            sell = max(sell, hold + prices[i] - price - fee);</span><br><span class="line">            <span class="keyword">if</span>(tmpsell + price - prices[i]] &gt; hold)</span><br><span class="line">            &#123;</span><br><span class="line">                hold = tmpsell;</span><br><span class="line">                price = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Solution Two</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>: </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxProfit</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; prices, <span class="keyword">int</span> fee)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sell = <span class="number">0</span>, hold = -prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>;i &lt; prices.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> tmpsell  = sell;</span><br><span class="line">            sell = max(sell, hold + prices[i] - fee);</span><br><span class="line">            hold = max(hold, tmpsell - prices[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sell;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-275-H-Index2"><a href="#5-Leetcode-275-H-Index2" class="headerlink" title="5. Leetcode 275. H-Index2"></a>5. <a href="https://leetcode.com/problems/h-index-ii/description/" target="_blank" rel="noopener">Leetcode 275. H-Index2</a></h4><p>Given an array of citations sorted in ascending order (each citation is a non-negative integer) of a researcher, write a function to compute the researcher’s h-index.</p><p>According to the definition of h-index on Wikipedia: “A scientist has index h if h of his/her N papers have at least h citations each, and the other N − h papers have no more than h citations each.”</p><p>Example:</p><p>Input: citations = [0,1,3,5,6]<br>Output: 3<br>Explanation: [0,1,3,5,6] means the researcher has 5 papers in total and each of them had<br>             received 0, 1, 3, 5, 6 citations respectively.<br>             Since the researcher has 3 papers with at least 3 citations each and the remaining<br>             two with no more than 3 citations each, her h-index is 3.<br>Note:</p><p>If there are several possible values for h, the maximum one is taken as the h-index.</p><p>Follow up:</p><p>This is a follow up problem to H-Index, where citations is now guaranteed to be sorted in ascending order.<br>Could you solve it in logarithmic time complexity?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">hIndex</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; citations)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(citations.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> n = citations.size();</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (l + (r - l) / <span class="number">2</span>);</span><br><span class="line">            <span class="keyword">int</span> h = n - mid;</span><br><span class="line">            <span class="keyword">if</span>(citations[mid] &lt; h)</span><br><span class="line">                l = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                r = mid;</span><br><span class="line">        &#125;       </span><br><span class="line">        <span class="keyword">if</span>(citations[l] &gt;= n - l)</span><br><span class="line">            <span class="keyword">return</span> n - l;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-300-Longest-Increasing-Subsequence"><a href="#6-Leetcode-300-Longest-Increasing-Subsequence" class="headerlink" title="6. Leetcode 300. Longest Increasing Subsequence"></a>6. <a href="https://leetcode.com/problems/longest-increasing-subsequence/description/" target="_blank" rel="noopener">Leetcode 300. Longest Increasing Subsequence</a></h4><p>Given an unsorted array of integers, find the length of longest increasing subsequence.</p><p>Example:</p><p>Input: [10,9,2,5,3,7,101,18]<br>Output: 4<br>Explanation: The longest increasing subsequence is [2,3,7,101], therefore the length is 4.<br>Note:</p><p>There may be more than one LIS combination, it is only necessary for you to return the length.<br>Your algorithm should run in O(n2) complexity.<br>Follow up: Could you improve it to O(n log n) time complexity?</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">lengthOfLIS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">         <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; LIS;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nums.size();i++)</span><br><span class="line">         &#123;</span><br><span class="line">            <span class="keyword">if</span>(LIS.size() == <span class="number">0</span> <span class="keyword">or</span> nums[i] &gt; LIS.back())</span><br><span class="line">                LIS.push_back(nums[i]);</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">auto</span> it = lower_bound(LIS.begin(), LIS.end(), nums[i]);</span><br><span class="line">                *it = nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;     </span><br><span class="line">         <span class="keyword">return</span> LIS.size();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h3><h4 id="1-Leetcode-312-Burst-Balloons"><a href="#1-Leetcode-312-Burst-Balloons" class="headerlink" title="1. Leetcode 312. Burst Balloons"></a>1. <a href="https://leetcode.com/problems/burst-balloons/description/" target="_blank" rel="noopener">Leetcode 312. Burst Balloons</a></h4><p>Given n balloons, indexed from 0 to n-1. Each balloon is painted with a number on it represented by array nums. You are asked to burst all the balloons. If the you burst balloon i you will get nums[left] <em> nums[i] </em> nums[right] coins. Here left and right are adjacent indices of i. After the burst, the left and right then becomes adjacent.</p><p>Find the maximum coins you can collect by bursting the balloons wisely.</p><p>Note:</p><p>You may imagine nums[-1] = nums[n] = 1. They are not real therefore you can not burst them.<br>0 ≤ n ≤ 500, 0 ≤ nums[i] ≤ 100<br>Example:</p><p>Input: [3,1,5,8]<br>Output: 167<br>Explanation: nums = [3,1,5,8] –&gt; [3,5,8] –&gt;   [3,8]   –&gt;  [8]  –&gt; []<br>             coins =  3<em>1</em>5      +  3<em>5</em>8    +  1<em>3</em>8      + 1<em>8</em>1   = 167</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maxCoins</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        nums.insert(nums.begin(), <span class="number">1</span>); nums.insert(nums.end(), <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">int</span> len = nums.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; memo(nums.size(),<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(nums.size(), <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> l = <span class="number">1</span>; l &lt;= len - <span class="number">2</span>; l++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; len - l;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> start = i, end = start + l - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> lastOne = start; lastOne &lt;= end; lastOne++)</span><br><span class="line">                &#123;</span><br><span class="line">                    memo[start][end] = max(memo[start][end], nums[lastOne] * nums[start<span class="number">-1</span>]*nums[end+<span class="number">1</span>] + (lastOne == start ? <span class="number">0</span> : memo[start][lastOne<span class="number">-1</span>]) + (lastOne == end ? <span class="number">0</span> : memo[lastOne+<span class="number">1</span>][end]) );</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> memo[<span class="number">1</span>][len<span class="number">-2</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day-3.md</title>
    <link href="https://gorillasx.github.io/2018/06/21/Preparing-For-Interview-Day-3/"/>
    <id>https://gorillasx.github.io/2018/06/21/Preparing-For-Interview-Day-3/</id>
    <published>2018-06-21T14:22:21.000Z</published>
    <updated>2018-06-22T14:42:12.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-669-Trim-a-Binary-Search-Tree"><a href="#1-Leetcode-669-Trim-a-Binary-Search-Tree" class="headerlink" title="1. Leetcode 669. Trim a Binary Search Tree"></a>1. <a href="https://leetcode.com/problems/trim-a-binary-search-tree/description/" target="_blank" rel="noopener">Leetcode 669. Trim a Binary Search Tree</a></h4><blockquote><p>Given a binary search tree and the lowest and highest boundaries as L and R, trim the tree so that all its elements lies in [L, R] (R &gt;= L). You might need to change the root of the tree, so the result should return the new root of the trimmed binary search tree.</p></blockquote><p><strong>Thought:</strong><br>We are given a binary search tree, so what characteristic of binary search tree can be used to solve this problem? The most important characteristic is all value in the right sub-tree all greater then root value, all value in left-subtree all smaller then root value. So if root value not in the range defined by [L, R], then the left subtree or right subtree will not in this range too. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">trimBST</span><span class="params">(TreeNode* root, <span class="keyword">int</span> L, <span class="keyword">int</span> R)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;val &gt; R)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;left, L, R);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(root-&gt;val &lt; L)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> trimBST(root-&gt;right, L, R);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;left = trimBST(root-&gt;left, L, R);</span><br><span class="line">            root-&gt;right = trimBST(root-&gt;right, L, R);</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-179-Largest-Number"><a href="#2-Leetcode-179-Largest-Number" class="headerlink" title="2. Leetcode 179. Largest Number"></a>2. <a href="https://leetcode.com/problems/largest-number/description/" target="_blank" rel="noopener">Leetcode 179. Largest Number</a></h4><p>Given a list of non negative integers, arrange them such that they form the largest number.</p><p>Note: The result may be very large, so you need to return a string instead of an integer.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">comp</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">      <span class="built_in">string</span> as = to_string(a) + to_string(b);</span><br><span class="line">      <span class="built_in">string</span> bs = to_string(b) + to_string(a);</span><br><span class="line">      <span class="keyword">return</span> as &gt; bs;</span><br><span class="line">&#125;   </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">largestNumber</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">""</span>;</span><br><span class="line">        </span><br><span class="line">        sort(nums.begin(), nums.end(), comp);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>] == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"0"</span>;</span><br><span class="line">        <span class="built_in">string</span> result = <span class="string">""</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> n : nums)</span><br><span class="line">            result += to_string(n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-296-Best-Meeting-Point"><a href="#3-Leetcode-296-Best-Meeting-Point" class="headerlink" title="3. Leetcode 296. Best Meeting Point"></a>3. <a href="https://leetcode.com/problems/best-meeting-point/description/" target="_blank" rel="noopener">Leetcode 296. Best Meeting Point</a></h4><blockquote><p>A group of two or more people wants to meet and minimize the total travel distance. You are given a 2D grid of values 0 or 1, where each 1 marks the home of someone in the group. The distance is calculated using Manhattan Distance, where distance(p1, p2) = |p2.x - p1.x| + |p2.y - p1.y|.</p></blockquote><p><strong>Thought:</strong><br>The brute force solution is straightforward. Traverse this grid, find all person positions. Then traverse this grid again, for every possible position calculating the total distance to all persons, then keep the smallest one. The time complexity is O(mn*person). We know we can not remove mn term, because we must to traverse every position at least once. Thus, how can we reduce the time to calculate total distance for every possible position. One important observation is that on a 1D line, the positions between two points will have same total distance to those two points. Also this distance is the smallest. If we have multiple points, then we want to sit at the middle point of those points. For this problem, the person position is 2D coordinate. But we can calculate horizontal and vertical distance separately. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Brute Force</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">       <span class="built_in">vector</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; person;</span><br><span class="line">       <span class="keyword">int</span> m = grid.size();</span><br><span class="line">       <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    person.emplace_back(i,j);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;   </span><br><span class="line">       <span class="keyword">int</span> result = INT_MAX;</span><br><span class="line">       <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">       &#123;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">           &#123;</span><br><span class="line">               <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">               <span class="keyword">for</span>(<span class="keyword">auto</span> p : person)</span><br><span class="line">               &#123;</span><br><span class="line">                   distance = distance + <span class="built_in">abs</span>(i - p.first) + <span class="built_in">abs</span>(j - p.second);</span><br><span class="line">               &#125;</span><br><span class="line">               result = min(result, distance);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; </span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Optimal</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetRow</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>)</span><br><span class="line">                    row.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GetCol</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; col)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; m;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[j][i] == <span class="number">1</span>)</span><br><span class="line">                    col.push_back(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; pos)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span>  l = <span class="number">0</span>, r = pos.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> distance = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(l &lt; r)</span><br><span class="line">        &#123;</span><br><span class="line">            distance += (pos[r] - pos[l]);</span><br><span class="line">            r--;</span><br><span class="line">            l++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> distance;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minTotalDistance</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; row;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; col;</span><br><span class="line">        GetRow(grid, row);</span><br><span class="line">        GetCol(grid, col);</span><br><span class="line">        <span class="keyword">return</span> calDistance(row) + calDistance(col);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-164-Maximum-Gap"><a href="#4-Leetcode-164-Maximum-Gap" class="headerlink" title="4. Leetcode 164. Maximum Gap"></a>4. <a href="https://leetcode.com/problems/maximum-gap/description/" target="_blank" rel="noopener">Leetcode 164. Maximum Gap</a></h4><blockquote><p>Given an unsorted array, find the maximum difference between the successive elements in its sorted form.<br>Return 0 if the array contains less than 2 elements.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">maximumGap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(nums.size() &lt;= <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> minmaxIter = minmax_element(nums.begin(), nums.end());       </span><br><span class="line">        pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt; minmax(*minmaxIter.first, *minmaxIter.second);</span><br><span class="line">        <span class="keyword">int</span> minGap = max(<span class="number">1</span>, (minmax.second - minmax.first) / (nums.size() - <span class="number">1</span>));</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> buckets = (minmax.second - minmax.first) / minGap + <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucketMin(buckets, INT_MAX);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; bucketMax(buckets, INT_MIN);</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; have;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> index = (num - minmax.first) / minGap;</span><br><span class="line">            have.insert(index);</span><br><span class="line">            bucketMin[index] = min(bucketMin[index], num);</span><br><span class="line">            bucketMax[index] = max(bucketMax[index], num);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(have.count(i) == <span class="number">0</span>)</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = i + <span class="number">1</span>;j &lt; buckets; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(have.count(j) != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                result = max(result, bucketMin[j] - bucketMax[j<span class="number">-1</span>]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">               bucketMin[j] = bucketMin[j<span class="number">-1</span>];</span><br><span class="line">               bucketMax[j] = bucketMax[j<span class="number">-1</span>]; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>Thought:</strong></p><h4 id="5-Leetcode-174-Dungeon-Game"><a href="#5-Leetcode-174-Dungeon-Game" class="headerlink" title="5. Leetcode 174. Dungeon Game"></a>5. <a href="https://leetcode.com/problems/dungeon-game/description/" target="_blank" rel="noopener">Leetcode 174. Dungeon Game</a></h4><blockquote><p>The demons had captured the princess (P) and imprisoned her in the bottom-right corner of a dungeon. The dungeon consists of M x N rooms laid out in a 2D grid. Our valiant knight (K) was initially positioned in the top-left room and must fight his way through the dungeon to rescue the princess.<br>The knight has an initial health point represented by a positive integer. If at any point his health point drops to 0 or below, he dies immediately.<br>Some of the rooms are guarded by demons, so the knight loses health (negative integers) upon entering these rooms; other rooms are either empty (0’s) or contain magic orbs that increase the knight’s health (positive integers).<br>In order to reach the princess as quickly as possible, the knight decides to move only rightward or downward in each step.<br>Write a function to determine the knight’s minimum initial health so that he is able to rescue the princess.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">calculateMinimumHP</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; dungeon)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = dungeon.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? dungeon[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; dp(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        dp[m][n<span class="number">-1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[n<span class="number">-1</span>][m] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = m;i &gt;= <span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = n;j &gt;= <span class="number">0</span>;j--)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mini = min(dp[i+<span class="number">1</span>][j], dp[i][j+<span class="number">1</span>]) - dungeon[i][j];</span><br><span class="line">                dp[i][j] = (mini &lt;= <span class="number">0</span> ? <span class="number">1</span> : mini);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-786-Kth-Smallest-Prime-Fraction"><a href="#6-Leetcode-786-Kth-Smallest-Prime-Fraction" class="headerlink" title="6. Leetcode 786. Kth Smallest Prime Fraction"></a>6. <a href="https://leetcode.com/problems/k-th-smallest-prime-fraction/solution/" target="_blank" rel="noopener">Leetcode 786. Kth Smallest Prime Fraction</a></h4><blockquote><p>A sorted list A contains 1, plus some number of primes.  Then, for every p &lt; q in the list, we consider the fraction p/q.<br>What is the K-th smallest fraction considered?  Return your answer as an array of ints, where answer[0] = p and answer[1] = q.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; smallerThan(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K, <span class="keyword">double</span> mid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res(<span class="number">3</span>, <span class="number">0</span>);</span><br><span class="line">        res[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(; j &lt; A.size();j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">double</span>(A[i]) / <span class="keyword">double</span>(A[j]) &lt; mid)</span><br><span class="line">                i++;</span><br><span class="line">            res[<span class="number">0</span>] += i;</span><br><span class="line">            <span class="keyword">if</span>(i &gt; <span class="number">0</span> &amp;&amp; (<span class="keyword">double</span>(A[i<span class="number">-1</span>]) / <span class="keyword">double</span>(A[j])) &gt; <span class="keyword">double</span>(res[<span class="number">1</span>]) / <span class="keyword">double</span>(res[<span class="number">2</span>]))</span><br><span class="line">            &#123;</span><br><span class="line">                res[<span class="number">1</span>] = A[i<span class="number">-1</span>];</span><br><span class="line">                res[<span class="number">2</span>] = A[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; kthSmallestPrimeFraction(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; A, <span class="keyword">int</span> K)&#123;</span><br><span class="line">        <span class="keyword">double</span> left  = <span class="keyword">double</span>(A.front()) / <span class="keyword">double</span>(A.back());</span><br><span class="line">        <span class="keyword">double</span> right = <span class="number">1.0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans(<span class="number">2</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">while</span>(right - left &lt; <span class="number">1e-9</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">double</span> mid = (left + right) / <span class="number">2</span>;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; res = smallerThan(A, K, mid);</span><br><span class="line">            <span class="keyword">if</span>(res &lt; K)</span><br><span class="line">                left = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                right = mid;</span><br><span class="line">                ans[<span class="number">0</span>] = res[<span class="number">1</span>];</span><br><span class="line">                ans[<span class="number">1</span>] = res[<span class="number">2</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview Day 2</title>
    <link href="https://gorillasx.github.io/2018/06/20/Preparing-For-Interview-Day-2/"/>
    <id>https://gorillasx.github.io/2018/06/20/Preparing-For-Interview-Day-2/</id>
    <published>2018-06-20T13:26:59.000Z</published>
    <updated>2018-06-21T00:33:29.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Something-New"><a href="#1-Something-New" class="headerlink" title="1. Something New"></a>1. Something New</h3><h4 id="1-Leetcode-547-FriendCircles"><a href="#1-Leetcode-547-FriendCircles" class="headerlink" title="1.Leetcode 547. FriendCircles"></a>1.<a href="https://leetcode.com/problems/friend-circles/description/" target="_blank" rel="noopener">Leetcode 547. FriendCircles</a></h4><blockquote><p>There are N students in a class. Some of them are friends, while some are not. Their friendship is transitive in nature. For example, if A is a direct friend of B, and B is a direct friend of C, then A is an indirect friend of C. And we defined a friend circle is a group of students who are direct or indirect friends.<br>Given a N*N matrix M representing the friend relationship between students in the class. If M[i][j] = 1, then the ith and jth students are direct friends with each other, otherwise not. And you have to output the total number of friend circles among all the students.</p></blockquote><p><strong>Thought:</strong><br>At the beginning, we treat each student as a circle, then we have N circles. Then we according to the relationships between students to connect those circles, After connecting two circles together, the number of total circles will minus one. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findCircleNum</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; M)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n =   M.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        <span class="keyword">int</span> count = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i != j &amp;&amp; M[i][j] == <span class="number">1</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> left = i;</span><br><span class="line">                    <span class="keyword">int</span> right = j;</span><br><span class="line">                    <span class="keyword">while</span>(parents[left] != left)</span><br><span class="line">                        left = parents[left];</span><br><span class="line">                    <span class="keyword">while</span>(parents[right] != right)</span><br><span class="line">                        right = parents[right];</span><br><span class="line">                    parents[i] = left;</span><br><span class="line">                    parents[j] = right;</span><br><span class="line">                    <span class="keyword">if</span>(left != right)</span><br><span class="line">                    &#123;</span><br><span class="line">                        parents[left] = right;</span><br><span class="line">                        count--;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-694-Number-Of-Distinct-islands"><a href="#2-Leetcode-694-Number-Of-Distinct-islands" class="headerlink" title="2. Leetcode 694. Number Of Distinct islands"></a>2. <a href="https://leetcode.com/problems/number-of-distinct-islands/description/" target="_blank" rel="noopener">Leetcode 694. Number Of Distinct islands</a></h4><blockquote><p>Given a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.<br>Count the number of distinct islands. An island is considered to be the same as another if and only if one island can be translated (and not rotated or reflected) to equal the other.</p></blockquote><p><strong>Thought:</strong><br>The intuition of solving this problem can be summarized in two steps:</p><ol><li>Find all islands,</li><li>Put all islands into a set, then the size of the set will be the number of distinct islands. </li></ol><p>Find all islands could be done by using a straightforward depth-first search. The hard part is deciding whether two islands are the same. </p><p>Two islands are considered same when they have same shape. we need to find a representation to represent each islands and this representation should also contain shape information. Can we get this shape information, when we do DFS? Yes, the DFS function we called will follow a certain path, thus, if two islands have same shape, they should have same DFS path, if they start at a same point. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">numDistinctIslands</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="built_in">string</span>&gt; signatures;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>;j &lt; n;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span> &amp;&amp; visited[i][j] == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">string</span> signature = DFS(grid, visited, i, j, <span class="number">0</span>);</span><br><span class="line">                    signatures.insert(signature);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> signatures.size();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> r, <span class="keyword">int</span> c, <span class="keyword">int</span> direction)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">string</span> signature = to_string(direction);</span><br><span class="line">        visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> row = r + delta[i];</span><br><span class="line">            <span class="keyword">int</span> col = c + delta[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(row &gt;= <span class="number">0</span> &amp;&amp; row &lt; grid.size() &amp;&amp; col &gt;= <span class="number">0</span> &amp;&amp; col &lt; grid[<span class="number">0</span>].size() &amp;&amp; grid[row][col] == <span class="number">1</span> &amp;&amp; visited[row][col] == <span class="literal">false</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                signature += DFS(grid, visited, row, col, i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        signature += <span class="string">"b"</span>;</span><br><span class="line">        <span class="keyword">return</span> signature;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-851-Loud-And-Rich"><a href="#3-Leetcode-851-Loud-And-Rich" class="headerlink" title="3. Leetcode 851. Loud And Rich"></a>3. <a href="https://leetcode.com/problems/loud-and-rich/description/" target="_blank" rel="noopener">Leetcode 851. Loud And Rich</a></h4><blockquote><p>In a group of N people (labelled 0, 1, 2, …, N-1), each person has different amounts of money, and different levels of quietness.<br>For convenience, we’ll call the person with label x, simply “person x”.<br>We’ll say that richer[i] = [x, y] if person x definitely has more money than person y.  Note that richer may only be a subset of valid observations.<br>Also, we’ll say quiet[x] = q if person x has quietness q.<br>Now, return answer, where answer[x] = y if y is the least quiet person (that is, the person y with the smallest value of quiet[y]), among all people who definitely have equal to or more money than person x.</p></blockquote><p><strong>Thought:</strong> </p><p>At the first glance, this problem is simple, we could easily create a hashmap maps from a person to a list of person that richer than this person, but one thing we need to notice is that this hashmap created from the richer input, is only a subset of valid observation. We need to pay more attention to this. DFS should be used to search all the person that richer than current person. Another thing is, there are many overlap calculation. We could use memorization to avoid this. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; loudAndRich(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richer, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; richerThan;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; memo;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> pair : richer)</span><br><span class="line">        &#123;</span><br><span class="line">            richerThan[pair[<span class="number">1</span>]].push_back(pair[<span class="number">0</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> NumberOfPerson = quiet.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; result;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; NumberOfPerson;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> quietness = DFSSearchRicher(richerThan, quiet, memo,  i);</span><br><span class="line">            result.push_back(quietness);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">DFSSearchRicher</span><span class="params">(<span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; richerThan, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; quiet, <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&amp; memo, <span class="keyword">int</span> person)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(memo.count(person) != <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> memo[person];</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> quietness = person;</span><br><span class="line">        <span class="keyword">if</span>(richerThan.count(person) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">auto</span> richer : richerThan[person])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> tmp = DFSSearchRicher(richerThan, quiet, memo, richer);</span><br><span class="line">                <span class="keyword">if</span>(quiet[tmp] &lt;= quiet[quietness])</span><br><span class="line">                    quietness = tmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        memo[person] = quietness;</span><br><span class="line">        <span class="keyword">return</span> quietness;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-491-Increasing-Subsequences"><a href="#4-Leetcode-491-Increasing-Subsequences" class="headerlink" title="4. Leetcode 491. Increasing Subsequences"></a>4. <a href="https://leetcode.com/problems/increasing-subsequences/description/" target="_blank" rel="noopener">Leetcode 491. Increasing Subsequences</a></h4><blockquote><p>Given an integer array, your task is to find all the different possible increasing subsequences of the given array, and the length of an increasing subsequence should be at least 2 .<br>Example:<br>Input: [4, 6, 7, 7]<br>Output: [[4, 6], [4, 7], [4, 6, 7], [4, 6, 7, 7], [6, 7], [6, 7, 7], [7,7], [4,7,7]]<br>Note:</p><ol><li>The length of the given array will not exceed 15.</li><li>The range of integer in the given array is [-100,100].</li><li>The given array may contain duplicates, and two equal integers should also be considered as a special case of increasing sequence.</li></ol></blockquote><p><strong>Thought:</strong> </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; findSubsequences(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; results;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; cur;</span><br><span class="line">        DFS(nums, <span class="number">0</span>, cur, results);</span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> pos, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; cur, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; result)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cur.size() &gt;= <span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            result.push_back(cur);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(pos == nums.size())</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">unordered_set</span>&lt;<span class="keyword">int</span>&gt; visited;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = pos; i&lt; nums.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((cur.size() == <span class="number">0</span> || nums[i] &gt;= cur.back()) &amp;&amp; visited.count(nums[i]) == <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                visited.insert(nums[i]);</span><br><span class="line">                cur.push_back(nums[i]);</span><br><span class="line">                DFS(nums, i + <span class="number">1</span>, cur, result);</span><br><span class="line">                cur.pop_back();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-129-Sum-Root-to-Leaf-Numbers"><a href="#5-Leetcode-129-Sum-Root-to-Leaf-Numbers" class="headerlink" title="5. Leetcode 129. Sum Root to Leaf Numbers"></a>5. <a href="https://leetcode.com/problems/sum-root-to-leaf-numbers/description/" target="_blank" rel="noopener">Leetcode 129. Sum Root to Leaf Numbers</a></h4><blockquote><p>Given a binary tree containing digits from 0-9 only, each root-to-leaf path could represent a number.<br>An example is the root-to-leaf path 1-&gt;2-&gt;3 which represents the number 123.<br>Find the total sum of all root-to-leaf numbers.<br>Note: A leaf is a node with no children.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">sumNumbers</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> totalSum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> totalSum;</span><br><span class="line">        DFS(root, root-&gt;val, totalSum);</span><br><span class="line">        <span class="keyword">return</span> totalSum;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">DFS</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curValue, <span class="keyword">int</span>&amp; totalSum)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            totalSum += curValue;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(root-&gt;left, curValue * <span class="number">10</span> + root-&gt;left-&gt;val, totalSum);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            &#123;</span><br><span class="line">                DFS(root-&gt;right, curValue * <span class="number">10</span> + root-&gt;right-&gt;val, totalSum);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-339-Nested-List-Weight-Sum"><a href="#6-Leetcode-339-Nested-List-Weight-Sum" class="headerlink" title="6. Leetcode 339. Nested List Weight Sum"></a>6. <a href="https://leetcode.com/problems/nested-list-weight-sum/description/" target="_blank" rel="noopener">Leetcode 339. Nested List Weight Sum</a></h4><blockquote><p>Given a nested list of integers, return the sum of all integers in the list weighted by their depth.<br>Each element is either an integer, or a list – whose elements may also be integers or other lists.<br>Example 1:<br>Given the list [[1,1],2,[1,1]], return 10. (four 1’s at depth 2, one 2 at depth 1)<br>Example 2:<br>Given the list [1,[4,[6]]], return 27. (one 1 at depth 1, one 4 at depth 2, and one 6 at depth 3; 1 + 4<em>2 + 6</em>3 = 27)</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * // This is the interface that allows for creating nested lists.</span></span><br><span class="line"><span class="comment"> * // You should not implement it, or speculate about its implementation</span></span><br><span class="line"><span class="comment"> * class NestedInteger &#123;</span></span><br><span class="line"><span class="comment"> *   public:</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes an empty nested list.</span></span><br><span class="line"><span class="comment"> *     NestedInteger();</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Constructor initializes a single integer.</span></span><br><span class="line"><span class="comment"> *     NestedInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return true if this NestedInteger holds a single integer, rather than a nested list.</span></span><br><span class="line"><span class="comment"> *     bool isInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the single integer that this NestedInteger holds, if it holds a single integer</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a nested list</span></span><br><span class="line"><span class="comment"> *     int getInteger() const;</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a single integer.</span></span><br><span class="line"><span class="comment"> *     void setInteger(int value);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Set this NestedInteger to hold a nested list and adds a nested integer to it.</span></span><br><span class="line"><span class="comment"> *     void add(const NestedInteger &amp;ni);</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> *     // Return the nested list that this NestedInteger holds, if it holds a nested list</span></span><br><span class="line"><span class="comment"> *     // The result is undefined if this NestedInteger holds a single integer</span></span><br><span class="line"><span class="comment"> *     const vector&lt;NestedInteger&gt; &amp;getList() const;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">depthSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> CalCulSum(nestedList, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">CalCulSum</span><span class="params">(<span class="built_in">vector</span>&lt;NestedInteger&gt;&amp; nestedList, <span class="keyword">int</span> depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; nestedList.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(nestedList[i].isInteger())</span><br><span class="line">            &#123;</span><br><span class="line">                sum += (nestedList[i].getInteger() * depth);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                sum += CalCulSum(nestedList[i].getList(), depth + <span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sum;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Review-Old"><a href="#2-Review-Old" class="headerlink" title="2. Review Old"></a>2. Review Old</h3><h4 id="1-Leetcode-527-Word-Abbreviation"><a href="#1-Leetcode-527-Word-Abbreviation" class="headerlink" title="1. Leetcode 527. Word Abbreviation"></a>1. <a href="https://leetcode.com/problems/word-abbreviation/description/" target="_blank" rel="noopener">Leetcode 527. Word Abbreviation</a></h4><blockquote><p>Given an array of n distinct non-empty strings, you need to generate minimal possible abbreviations for every word following rules below.</p><ol><li>Begin with the first character and then the number of characters abbreviated, which followed by the last character.</li><li>If there are any conflict, that is more than one words share the same abbreviation, a longer prefix is used instead of only the first character until making the map from word to abbreviation become unique. In other words, a final abbreviation cannot map to more than one original words.</li><li>If the abbreviation doesn’t make the word shorter, then keep it as original.</li></ol></blockquote><p><strong>Thought:</strong><br>It’s easy to generate minimal abbreviation for each non-empty string, the hard part is how to make it unique. If there are multiple strings with same length, same first character, same last character, they will generate same minimal abbreviation. one way could make their abbreviation unique is having a longer prefix. How long will be enough for a string generating an unique abbreviation? If there is only one string with this prefix, then this prefix is a valid prefix. Trie is the ideal data structure could help us finding a valid prefix easily.<br>For each Trie node, we not only need to store children node pointers, but also a counter used to cound how many string have current prefix. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Trie</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    Trie()&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">insert</span><span class="params">(<span class="built_in">string</span>&amp; word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; word.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">if</span>(node-&gt;child[word[i] - <span class="string">'a'</span>] == <span class="literal">NULL</span>)</span><br><span class="line">                node-&gt;child[word[i] - <span class="string">'a'</span>] = <span class="keyword">new</span> Trie();</span><br><span class="line">           node = node-&gt;child[word[i] - <span class="string">'a'</span>];</span><br><span class="line">           (node-&gt;count)++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="built_in">string</span> <span class="title">FindAbbr</span><span class="params">(<span class="built_in">string</span>&amp; word)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        Trie* node = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; word.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            node = node-&gt;child[word[i] - <span class="string">'a'</span>];</span><br><span class="line">            <span class="keyword">if</span>(node-&gt;count == <span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(i == word.size() - <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> word;</span><br><span class="line">                <span class="built_in">string</span> abb = word.substr(<span class="number">0</span>, i + <span class="number">1</span>) + to_string(word.size() - i - <span class="number">2</span>) + word.back();</span><br><span class="line">                <span class="keyword">return</span> (abb.size() &gt;= word.size() ? word : abb);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    Trie* child[<span class="number">26</span>] = &#123;<span class="literal">NULL</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">    ~Trie()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">26</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(child[i] != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">delete</span> child[i];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; wordsAbbreviation(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; dict) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&gt; groups;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : dict)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">string</span> key = word.front() + to_string(word.size() - <span class="number">2</span>) + word.back();</span><br><span class="line">            groups[key].push_back(word);</span><br><span class="line">        &#125;        </span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>, <span class="built_in">string</span>&gt; abbrMap;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> group : groups)</span><br><span class="line">        &#123;</span><br><span class="line">            GenerateAbbr(group.first, group.second, abbrMap);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : dict)</span><br><span class="line">        &#123;</span><br><span class="line">            res.push_back(abbrMap[word]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">GenerateAbbr</span><span class="params">(<span class="built_in">string</span> abbr, <span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">unordered_map</span>&lt;<span class="built_in">string</span>,<span class="built_in">string</span>&gt;&amp; abbrMap)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(words.size() == <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            abbrMap[words[<span class="number">0</span>]] = (abbr.size() &gt;= words[<span class="number">0</span>].size() ? words[<span class="number">0</span>] : abbr);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        Trie* root = <span class="keyword">new</span> Trie();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            root-&gt;insert(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> word : words)</span><br><span class="line">        &#123;</span><br><span class="line">            abbrMap[word] = root-&gt;FindAbbr(word);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Something-New&quot;&gt;&lt;a href=&quot;#1-Something-New&quot; class=&quot;headerlink&quot; title=&quot;1. Something New&quot;&gt;&lt;/a&gt;1. Something New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Preparing For Interview - Day 1</title>
    <link href="https://gorillasx.github.io/2018/06/19/Preparing-For-Interview-Day-1/"/>
    <id>https://gorillasx.github.io/2018/06/19/Preparing-For-Interview-Day-1/</id>
    <published>2018-06-19T12:58:42.000Z</published>
    <updated>2018-06-20T13:22:14.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Somthing-New"><a href="#1-Somthing-New" class="headerlink" title="1. Somthing New"></a>1. Somthing New</h3><h4 id="1-Leetcode-690-EmployeeImportance"><a href="#1-Leetcode-690-EmployeeImportance" class="headerlink" title="1. Leetcode 690.EmployeeImportance"></a>1. <a href="https://leetcode.com/problems/employee-importance/description/" target="_blank" rel="noopener">Leetcode 690.EmployeeImportance</a></h4><p>You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id.<br>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.<br>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.</p><blockquote><p>Example 1:<br>Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>Output: 11<br>Explanation:<br>Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.<br>Note:<br>One employee has at most one direct leader and may have several subordinates.<br>The maximum number of employees won’t exceed 2000.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    // It's the unique ID of each node.</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Employee*&gt; employeeMap;</span><br><span class="line">        <span class="keyword">for</span>(Employee* Employee : employees)</span><br><span class="line">            employeeMap[Employee-&gt;id] = Employee;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; start;</span><br><span class="line">        start.push(id);</span><br><span class="line">        <span class="keyword">int</span> totalScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!start.empty())</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> id = start.front(); start.pop();</span><br><span class="line">           totalScore += employeeMap[id]-&gt;importance;  </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>&amp; sub : employeeMap[id]-&gt;subordinates)  </span><br><span class="line">           &#123;</span><br><span class="line">               start.push(sub);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalScore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-107-Binary-Tree-Level-Order-Traverse-2"><a href="#2-Leetcode-107-Binary-Tree-Level-Order-Traverse-2" class="headerlink" title="2. Leetcode 107.Binary Tree Level Order Traverse 2"></a>2. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Leetcode 107.Binary Tree Level Order Traverse 2</a></h4><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">             <span class="keyword">return</span>  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; curLevel; </span><br><span class="line">        curLevel.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!curLevel.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = curLevel.size();</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = curLevel.front(); curLevel.pop();</span><br><span class="line">                result.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) curLevel.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) curLevel.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Solution two</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseToGetHeight</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curHeight, <span class="keyword">int</span>&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        TraverseToGetHeight(root-&gt;left,  curHeight + <span class="number">1</span>, height);</span><br><span class="line">        height = max(height, curHeight);</span><br><span class="line">        TraverseToGetHeight(root-&gt;right, curHeight + <span class="number">1</span>, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">             <span class="keyword">return</span>  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TraverseToGetHeight(root, <span class="number">1</span>, height);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(height, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; curLevel; </span><br><span class="line">        curLevel.push(root);</span><br><span class="line">        <span class="keyword">int</span> level = height - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!curLevel.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = curLevel.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = curLevel.front(); curLevel.pop();</span><br><span class="line">                result[level].push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) curLevel.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) curLevel.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-111-Minimum-Depth-Of-Binary-Tree"><a href="#3-Leetcode-111-Minimum-Depth-Of-Binary-Tree" class="headerlink" title="3. Leetcode 111.Minimum Depth Of Binary Tree"></a>3. <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode 111.Minimum Depth Of Binary Tree</a></h4><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Solution One: Brute Force O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = INT_MAX;</span><br><span class="line">        minDepth(root, <span class="number">1</span>, depth);</span><br><span class="line">        <span class="keyword">return</span> depth; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minDepth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curDepth, <span class="keyword">int</span>&amp; depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               depth = min(depth, curDepth);</span><br><span class="line">               <span class="keyword">return</span>; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;left)  minDepth(root-&gt;left, curDepth + <span class="number">1</span>,  depth);</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;right) minDepth(root-&gt;right, curDepth + <span class="number">1</span>, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two: BFS, better then O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; levels;</span><br><span class="line">        levels.push(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!levels.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = levels.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">               TreeNode* node = levels.front(); levels.pop();</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> level;  </span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) levels.push(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) levels.push(node-&gt;right);  </span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-513-Find-Bottom-Left-Tree-Value"><a href="#4-Leetcode-513-Find-Bottom-Left-Tree-Value" class="headerlink" title="4. Leetcode 513.Find Bottom Left Tree Value"></a>4. <a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode 513.Find Bottom Left Tree Value</a></h4><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution one, O(n) Brute Force, Two Pass Traverse</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curL, <span class="keyword">int</span>&amp; level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        FindLevel(root-&gt;left, curL + <span class="number">1</span>, level);</span><br><span class="line">        level = max(level, curL);</span><br><span class="line">        FindLevel(root-&gt;right, curL + <span class="number">1</span>, level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curl, <span class="keyword">int</span> level, <span class="keyword">int</span>&amp; value, <span class="keyword">bool</span>&amp; find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        GetValue(root-&gt;left, curl + <span class="number">1</span>, level, value, find);</span><br><span class="line">        <span class="keyword">if</span>(find)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curl == level &amp;&amp; !find)</span><br><span class="line">        &#123;</span><br><span class="line">            value = root-&gt;val;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        GetValue(root-&gt;right, curl + <span class="number">1</span>, level, value, find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        FindLevel(root, <span class="number">0</span>, level);</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">        GetValue(root, <span class="number">0</span>, level, value, find);</span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two, BFS, O(n) one pass traverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">        level.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!level.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            result = level.front()-&gt;val;</span><br><span class="line">            <span class="keyword">size_t</span> size = level.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = level.front(); level.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) level.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) level.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-515-Find-Largest-Value-In-Each-Tree-Row"><a href="#5-Leetcode-515-Find-Largest-Value-In-Each-Tree-Row" class="headerlink" title="5. Leetcode 515.Find Largest Value In Each Tree Row"></a>5. <a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/" target="_blank" rel="noopener">Leetcode 515.Find Largest Value In Each Tree Row</a></h4><p>You need to find the largest value in each row of a binary tree.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            level.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!level.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = level.size();</span><br><span class="line">            <span class="keyword">int</span> maxValue = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">               TreeNode* node = level.front(); level.pop();</span><br><span class="line">               maxValue = max(maxValue, node-&gt;val);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) level.push(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) level.push(node-&gt;right);   </span><br><span class="line">            &#125;</span><br><span class="line">            results.push_back(maxValue);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-529-Minesweeper"><a href="#6-Leetcode-529-Minesweeper" class="headerlink" title="6. Leetcode 529. Minesweeper!"></a>6. <a href="Let&#39;s play the minesweeper game (Wikipedia, online game">Leetcode 529. Minesweeper</a>!</h4><p>You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine.</p><p>Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules:</p><p>If a mine (‘M’) is revealed, then the game is over - change it to ‘X’.<br>If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively.<br>If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.<br>Return the board when no more squares will be revealed.)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? board[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; clicks;</span><br><span class="line">        clicks.push(click);</span><br><span class="line">        <span class="keyword">while</span>(!clicks.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c = clicks.front(); clicks.pop();</span><br><span class="line">            <span class="keyword">int</span> row = c[<span class="number">0</span>], col = c[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> mineCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = row + i;</span><br><span class="line">                    <span class="keyword">int</span> c = col + j;</span><br><span class="line">                    <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; board[r][c] == <span class="string">'M'</span>)</span><br><span class="line">                        mineCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mineCount != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                board[row][col] = <span class="string">'0'</span> + mineCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">-1</span>;j &lt; <span class="number">2</span>;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i;</span><br><span class="line">                        <span class="keyword">int</span> c = col + j;</span><br><span class="line">                        <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; board[r][c] == <span class="string">'E'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">                            clicks.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;r, c&#125;));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h3><h4 id="1-Leetcode-732-My-Calender-3"><a href="#1-Leetcode-732-My-Calender-3" class="headerlink" title="1. Leetcode 732. My Calender 3"></a>1. <a href="https://leetcode.com/problems/my-calendar-iii/description/" target="_blank" rel="noopener">Leetcode 732. My Calender 3</a></h4><blockquote><p>Implement a MyCalendarThree class to store your events. A new event can always be added.<br>Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end.<br>A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)<br>For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.<br>Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)</p></blockquote><p><strong>Thought:</strong><br>Every time, after inserting a new event, the largest K-book in the calender, need to be updated or not. Every time, when we have a new event, we want to know, where should we insert this event in, just like searching a right place. So the key point is how to make this searching efficient. If we can keep the events we have meet in some order according to there start time. Then we could use binary search to find a right place efficiently. So far, we want to build a binary search tree, then what should the node looks like in this binary search tree. It should have be used to represent a time slot, with a start time, and end time, and a counter used to count how many events overlaps with this time slot. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end, count;</span><br><span class="line">    STreeNode* left, * right;</span><br><span class="line">    STreeNode(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> c = <span class="number">1</span>):start(s), end(e), count(c), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(STreeNode*&amp; root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= root-&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;insert(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt;= root-&gt;start)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;insert(root-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> leftreturn = <span class="number">0</span>, rightreturn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; root-&gt;start)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newleft = <span class="keyword">new</span> STreeNode(start, root-&gt;start, count);</span><br><span class="line">                leftreturn = newleft-&gt;insert(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start &gt; root-&gt;start)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newleft = <span class="keyword">new</span> STreeNode(root-&gt;start, start, root-&gt;count);</span><br><span class="line">                newleft-&gt;left = root-&gt;left;</span><br><span class="line">                root-&gt;left = newleft;</span><br><span class="line">                root-&gt;start = start;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(end &gt; root-&gt;end)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newright = <span class="keyword">new</span> STreeNode(root-&gt;end, end, count);</span><br><span class="line">                rightreturn = newright-&gt;insert(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; root-&gt;end)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newright = <span class="keyword">new</span> STreeNode(end, root-&gt;end, root-&gt;count);</span><br><span class="line">                newright-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = newright;</span><br><span class="line">                root-&gt;end = end;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(root-&gt;count);</span><br><span class="line">            <span class="keyword">return</span> max(leftreturn, max(rightreturn, root-&gt;count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~STreeNode()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left)</span><br><span class="line">            <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">if</span>(right)</span><br><span class="line">            <span class="keyword">delete</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    STreeNode* root;</span><br><span class="line">    <span class="keyword">int</span> curMax;</span><br><span class="line">    MyCalendarThree(<span class="keyword">void</span>):root(<span class="literal">NULL</span>), curMax(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STreeNode* node = <span class="keyword">new</span> STreeNode(start, end);</span><br><span class="line">        <span class="keyword">int</span> count = node-&gt;insert(root);</span><br><span class="line">        curMax = max(curMax, count);</span><br><span class="line">        <span class="keyword">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyCalendarThree()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-765-Couples-Holding-Hands"><a href="#2-Leetcode-765-Couples-Holding-Hands" class="headerlink" title="2. Leetcode 765. Couples Holding Hands"></a>2. <a href="https://leetcode.com/problems/couples-holding-hands/description/" target="_blank" rel="noopener">Leetcode 765. Couples Holding Hands</a></h4><blockquote><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.<br>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).<br>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p></blockquote><p><strong>Thought:</strong><br>2N seats, N couples, we treat every two adjacent seats as a node, and two nodes could be connected if there is a valid swap, a valid swap means, after swapping two people, we can make at least one couple sitting together. Nodes connected by those valid swaps, then N nodes were grouped into several components. what we want to do to is cutting edges, doing swaps, then generating N isolated nodes. One fact we need to know is each swapping, we can only generate one more isolated node. Then, if we have a connected components, and want to generate b nodes, we only need to do b - a times swapping.</p><p>Another way to solve this question is, for each invalid node, which means the people sitting in this node is not a couple. Then we have two swapping choices to make it valid. If we think deeply, those two choices have same effect, which means, no matter we choose which choice, we can reach same result.<br>Then this problem can be solved by Greedy. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one: Union Find </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PersonToNode(row.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PersonToNode[row[i]] = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> components = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left  = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> right = (row[i] % <span class="number">2</span> == <span class="number">0</span> ? PersonToNode[row[i]+<span class="number">1</span>] : PersonToNode(row[i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(left == right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(parent[left] != left)</span><br><span class="line">                left = parent[left];</span><br><span class="line">            <span class="keyword">while</span>(parent[right] != right)</span><br><span class="line">                right = parent[right];</span><br><span class="line">            <span class="keyword">if</span>(left != right)</span><br><span class="line">            &#123;</span><br><span class="line">                parent[left] = right;</span><br><span class="line">                components--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - components;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Greedy </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PersonToNode(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">            PersonToNode[row[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = row[i];</span><br><span class="line">            <span class="keyword">int</span> right = row[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> target = row[i] % <span class="number">2</span> != <span class="number">0</span> ? row[i] - <span class="number">1</span> : row[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right == target) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            row[i+<span class="number">1</span>] = target;</span><br><span class="line">            PersonToNode[right] = PersonToNode[target];</span><br><span class="line">            row[PersonToNode[right]] = right;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-302-Smallest-Rectangle-Enclosing-Black-Pixels"><a href="#3-Leetcode-302-Smallest-Rectangle-Enclosing-Black-Pixels" class="headerlink" title="3. Leetcode 302. Smallest Rectangle Enclosing Black Pixels"></a>3. <a href="https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/description/" target="_blank" rel="noopener">Leetcode 302. Smallest Rectangle Enclosing Black Pixels</a></h4><blockquote><p>An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p></blockquote><p><strong>Thought:</strong><br>We are given an Image, and asked for a rectangle. So we need to think about how to represent a rectangle in an Image? A rectangle can be represented by two coordinates, left-bottom and right-top corner. It also can be represented by a point, corner or midpoint,  and the length of two different dimensions. For this problem, start from given black pixel, we can do Breath-first-search, to traverse every black pixel, and collect left-most, right-most, bottom-most, top-most information, which could be used to represent a rectangle. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; image, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? image[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = n - <span class="number">1</span>, right = <span class="number">0</span>, top = m - <span class="number">1</span>, bot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pixels;</span><br><span class="line">        pixels.emplace(x, y);</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!pixels.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> row = pixels.front().first;</span><br><span class="line">            <span class="keyword">int</span> col = pixels.front().second;</span><br><span class="line">            pixels.pop();</span><br><span class="line">            left = min(left, col);</span><br><span class="line">            right = max(right, col);</span><br><span class="line">            top = min(top, row);</span><br><span class="line">            bot = max(bot, row);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = row + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = col + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; visited[r][c] == <span class="literal">false</span> &amp;&amp; image[r][c] == <span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[r][c] =<span class="literal">true</span>;</span><br><span class="line">                    pixels.emplace(r,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left + <span class="number">1</span>) * (bot - top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-778-Swim-in-Rising-Water"><a href="#4-Leetcode-778-Swim-in-Rising-Water" class="headerlink" title="4. Leetcode 778. Swim in Rising Water"></a>4. <a href="https://leetcode.com/problems/swim-in-rising-water/description/" target="_blank" rel="noopener">Leetcode 778. Swim in Rising Water</a></h4><blockquote><p>On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).</p></blockquote><p>Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?</p><p><strong>Thought:</strong></p><p><em>Binary Search + DFS</em><br>At time t, the position that the depth of the water smaller that t, would be t. You can swim infinite distance in zero time if the start position and destination have same elevation. So we start at (0,0) and want to swim to (n-1, n-1), what’s the least time? There are many paths from (0,0) to (n-1, n-1), the highest elevation on each path will be the time that could make this path work. If we use the highest elevation on each path to score each path. Then we need to find a path with smallest score. Because we know the possible range of those scores, then we could do binary search to find the smallest score path. We could use Depth-First-Search to check whether at this time, we can reach (n - 1, n - 1)</p><p><em>Heap</em><br>At each position, we have four direction to move, how to choice next step will be the key point, because we can swim to any position in zero time, then the positions we have meet before all could be the next move. Therefore, we could use a minHeap to store all the position we can reach in next move, then every time when we want to move, we could find the position with lowest elevation to move, at the same time we want to record the highest elevation on this path until we reach (n-1, n-1). Since every time, we select a position from all reachable position which has lowest elevation, then the path from (0, 0) to (n-1, n-1) will be the path with smallest score. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one, Binary Search + DFS </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = grid[<span class="number">0</span>][<span class="number">0</span>], right = m * m <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + (right - left)/ <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">            visited[<span class="number">0</span>][<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(DFSCheck(grid, visited, mid, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, m <span class="number">-1</span>))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFSCheck</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> time, <span class="keyword">int</span> curRow, <span class="keyword">int</span> curCol , <span class="keyword">int</span> targetRow, <span class="keyword">int</span> targetCol)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curRow == targetRow &amp;&amp; curCol == targetCol)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = curRow + delta[i];</span><br><span class="line">            <span class="keyword">int</span> c = curCol + delta[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= targetRow &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt;= targetCol &amp;&amp; visited[r][c] == <span class="literal">false</span> &amp;&amp; grid[r][c] &lt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(DFSCheck(grid, visited, time, r, c, targetRow, targetCol))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution two: Heap </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> priority_queue&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, comp&gt; vectorMinHeap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        vectorMinHeap nextMove;</span><br><span class="line">        nextMove.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;  visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; move = nextMove.top();</span><br><span class="line">            nextMove.pop();</span><br><span class="line">            result = max(result, move[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(move[<span class="number">1</span>] == m <span class="number">-1</span> &amp;&amp; move[<span class="number">2</span>] == m <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = move[<span class="number">1</span>] + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = move[<span class="number">2</span>] + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; m &amp;&amp; visited[r][c] == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                    nextMove.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;grid[r][c], r, c&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Somthing-New&quot;&gt;&lt;a href=&quot;#1-Somthing-New&quot; class=&quot;headerlink&quot; title=&quot;1. Somthing New&quot;&gt;&lt;/a&gt;1. Somthing New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-690-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm collections</title>
    <link href="https://gorillasx.github.io/2018/04/26/Algorithm-collections/"/>
    <id>https://gorillasx.github.io/2018/04/26/Algorithm-collections/</id>
    <published>2018-04-26T21:13:49.000Z</published>
    <updated>2018-04-26T22:05:23.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Boyer-Moore-Algorithm"><a href="#1-Boyer-Moore-Algorithm" class="headerlink" title="1. Boyer-Moore Algorithm"></a>1. <a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html" target="_blank" rel="noopener">Boyer-Moore Algorithm</a></h3><p><strong>Description:</strong><br>Find the majority element in a list of values. This algorithm could be done in parallel.<br>Time complexity: O(n)<br>Spcae complexity: O(1)<br><strong>How it works:</strong><br>It required exactly 2 passes over the input list. </p><ol><li><p>In the first pass, we need to record a <em>candidate</em>, and the <em>count</em> of the <em>candicate</em>. At begining, <em>count</em> equal to 0, <em>candidate</em> could be any value.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">candidate = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> input:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        candidate = value</span><br><span class="line">    <span class="keyword">if</span> candidate == value:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        count -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Check whether this candidate is the majority element.</p></li></ol><p><strong>Explanation:</strong><br>At each point, where count == 0, means before that there are no elements exist or each element could find an another value to pair, to neutralize it. Thus, candidates before cannot be the majority element. But it also cannot guarantee the candidate we will get  at the end of traversal will me the majorith element, which is the reason we need a second pass. </p><p><strong>Practice:</strong><br><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Boyer-Moore-Algorithm&quot;&gt;&lt;a href=&quot;#1-Boyer-Moore-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;1. Boyer-Moore Algorithm&quot;&gt;&lt;/a&gt;1. &lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://gorillasx.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://gorillasx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>RNN</title>
    <link href="https://gorillasx.github.io/2018/04/12/RNN/"/>
    <id>https://gorillasx.github.io/2018/04/12/RNN/</id>
    <published>2018-04-13T00:41:38.000Z</published>
    <updated>2018-04-13T20:26:36.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Examples-of-RNN-architectures"><a href="#Examples-of-RNN-architectures" class="headerlink" title="Examples of RNN architectures"></a>Examples of RNN architectures</h3><h4 id="Many-to-Many-architecture"><a href="#Many-to-Many-architecture" class="headerlink" title="Many-to-Many architecture"></a>Many-to-Many architecture</h4><ol><li>Input length == Output length</li><li>Input length != Output length<h4 id="Many-to-One-architecture"><a href="#Many-to-One-architecture" class="headerlink" title="Many-to-One architecture"></a>Many-to-One architecture</h4>sentiment classification</li></ol><h4 id="One-to-Many-architecture"><a href="#One-to-Many-architecture" class="headerlink" title="One-to-Many architecture"></a>One-to-Many architecture</h4><p>Music generation</p><h3 id="Language-model-and-sequence-generation"><a href="#Language-model-and-sequence-generation" class="headerlink" title="Language model and sequence generation"></a>Language model and sequence generation</h3><h4 id="What-is-language-modelling"><a href="#What-is-language-modelling" class="headerlink" title="What is language modelling?"></a>What is language modelling?</h4><h4 id="language-modelling-with-an-RNN"><a href="#language-modelling-with-an-RNN" class="headerlink" title="language modelling with an RNN"></a>language modelling with an RNN</h4><p>Training set: large corpus of english text<br>Tokenize the sentences </p><h3 id="Vanishing-Gradient-problem"><a href="#Vanishing-Gradient-problem" class="headerlink" title="Vanishing Gradient problem"></a>Vanishing Gradient problem</h3><h3 id="Gated-Recurrent-Unit"><a href="#Gated-Recurrent-Unit" class="headerlink" title="Gated Recurrent Unit"></a>Gated Recurrent Unit</h3><p>It allows you to learn very long range connections in a sequecnce.</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><h3 id="Deep-RNNs"><a href="#Deep-RNNs" class="headerlink" title="Deep RNNs"></a>Deep RNNs</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Examples-of-RNN-architectures&quot;&gt;&lt;a href=&quot;#Examples-of-RNN-architectures&quot; class=&quot;headerlink&quot; title=&quot;Examples of RNN architectures&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://gorillasx.github.io/categories/Deep-Learning/"/>
    
      <category term="RNN" scheme="https://gorillasx.github.io/categories/Deep-Learning/RNN/"/>
    
    
      <category term="RNN" scheme="https://gorillasx.github.io/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>Implementing Interactive Physically Based Rendering On GPU notes(1)</title>
    <link href="https://gorillasx.github.io/2018/03/26/Implementing-Interactive-Physically-Based-Rendering-On-GPU-notes-1/"/>
    <id>https://gorillasx.github.io/2018/03/26/Implementing-Interactive-Physically-Based-Rendering-On-GPU-notes-1/</id>
    <published>2018-03-27T02:23:07.000Z</published>
    <updated>2018-03-28T04:18:02.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Machine Epsilon<br>Machine Epsilon is the smallest number of EPS(epsilon) such that 1 + EPS not equal to 1. Machine Epsilon is a machine-dependent floating point value that provides an upper bound on relative error due to rounding in floating point arithmetic. In C++, similar macros are available in the standard header. The preferred way in C++ is to use std::numeric_limits::epsilon( ) – specified in the standard header.</li><li><p>usage of <strong>CUDA_ARCH</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__device__ __<span class="function">host__ <span class="keyword">float</span> <span class="title">function</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0f</span> * __sinf(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0f</span> * <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html" target="_blank" rel="noopener">Diagnostic Pragmas</a></p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Machine Epsilon&lt;br&gt;Machine Epsilon is the smallest number of EPS(epsilon) such that 1 + EPS not equal to 1. Machine Epsilon is a ma
      
    
    </summary>
    
      <category term="Notes" scheme="https://gorillasx.github.io/categories/Notes/"/>
    
    
      <category term="CUDA" scheme="https://gorillasx.github.io/tags/CUDA/"/>
    
      <category term="Physically based rendering" scheme="https://gorillasx.github.io/tags/Physically-based-rendering/"/>
    
  </entry>
  
  <entry>
    <title>Update CUDA toolkit</title>
    <link href="https://gorillasx.github.io/2018/03/23/Update-CUDA-toolkit/"/>
    <id>https://gorillasx.github.io/2018/03/23/Update-CUDA-toolkit/</id>
    <published>2018-03-24T03:27:39.000Z</published>
    <updated>2018-04-21T16:02:36.000Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Update Nvidia GPU Driver</p><ol><li>Log into your account in the TTY</li><li><p>Run </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge nvidia-*</span><br></pre></td></tr></table></figure></li><li><p>Run </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure><p> and then</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>sudo apt-get install nvidia-390</p></li><li>Reboot</li></ol></li><li><p>Remove old CUDA toolkit</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge cuda</span><br></pre></td></tr></table></figure></li><li><p>Install new CUDA toolkit</p><ol><li><p>Install repository meta-data</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i cuda-repo-&lt;distro&gt;_&lt;version&gt;_&lt;architecture&gt;.deb</span><br></pre></td></tr></table></figure></li><li><p>Installing the CUDA public GPG key<br>When installing using the local repo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub</span><br></pre></td></tr></table></figure><p>When installing using network repo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/&lt;distro&gt;/&lt;architecture&gt;/7fa2af80.pub</span><br></pre></td></tr></table></figure></li><li><p>Update the Apt repository cache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Install CUDA</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cuda</span><br></pre></td></tr></table></figure></li><li><p>Environment Setup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=/usr/local/cuda-9.1/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">$ export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Update Nvidia GPU Driver&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Log into your account in the TTY&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="CUDA" scheme="https://gorillasx.github.io/categories/CUDA/"/>
    
    
      <category term="CUDA" scheme="https://gorillasx.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>C++ virtual function table</title>
    <link href="https://gorillasx.github.io/2018/03/15/C-virtual-function-table/"/>
    <id>https://gorillasx.github.io/2018/03/15/C-virtual-function-table/</id>
    <published>2018-03-16T02:55:55.000Z</published>
    <updated>2018-03-16T04:13:43.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for-understanding-C-polymorphism"><a href="#There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for-understanding-C-polymorphism" class="headerlink" title="There is a code example could be used to understand how C++ virtual function table existed and how it works. This is very important for understanding C++ polymorphism."></a>There is a code example could be used to understand how C++ virtual function table existed and how it works. This is very important for understanding C++ polymorphism.</h4><pre><code>**If there was a virtual function inside a class definition, then for each instance of this class, the first 8 bytes(64bits system) or 4 bytes(32bits system) is a pointer points to virtual function table. Virtual function table, in fact, is an arrar of function pointer, each function pointer points to a virtual function inorder as they declared. This virtual function table will be inherited by each derived class. If there are no virtual function override, then the virtual function table of derived class should be a copy of virtual function table of base class with same content. Otherwise, the virtual function table of derived class should be changed: the pointer points to the virtual function of base class should be replaced to the pointer points to virtual function of derived class**</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> x=<span class="number">8</span>):x(x)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent fun()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"show()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span><span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child(<span class="keyword">int</span> y= <span class="number">9</span>):y(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child fun()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Parent <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Child  c;</span><br><span class="line">    func** fa = <span class="keyword">reinterpret_cast</span>&lt;func**&gt;(&amp;p);</span><br><span class="line">    (*fa)[<span class="number">0</span>]();</span><br><span class="line">    (*fa)[<span class="number">1</span>]();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"father fun address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fa)[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"father show address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fa)[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func** fc = <span class="keyword">reinterpret_cast</span>&lt;func**&gt;(&amp;c);</span><br><span class="line">    (*fc)[<span class="number">0</span>]();</span><br><span class="line">    (*fc)[<span class="number">1</span>]();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Children fun address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fc)[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Children show address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fc)[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for
      
    
    </summary>
    
      <category term="C++" scheme="https://gorillasx.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://gorillasx.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Decision Tree</title>
    <link href="https://gorillasx.github.io/2018/03/10/Decision-Tree/"/>
    <id>https://gorillasx.github.io/2018/03/10/Decision-Tree/</id>
    <published>2018-03-11T01:18:56.000Z</published>
    <updated>2018-03-11T01:20:37.000Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="AI" scheme="https://gorillasx.github.io/categories/AI/"/>
    
      <category term="Machine Learning" scheme="https://gorillasx.github.io/categories/AI/Machine-Learning/"/>
    
      <category term="classification" scheme="https://gorillasx.github.io/categories/AI/Machine-Learning/classification/"/>
    
    
      <category term="Machine Learning" scheme="https://gorillasx.github.io/tags/Machine-Learning/"/>
    
      <category term="classification" scheme="https://gorillasx.github.io/tags/classification/"/>
    
  </entry>
  
  <entry>
    <title>C++ template</title>
    <link href="https://gorillasx.github.io/2018/03/10/C-template/"/>
    <id>https://gorillasx.github.io/2018/03/10/C-template/</id>
    <published>2018-03-10T18:45:32.000Z</published>
    <updated>2018-03-11T00:15:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates?"></a>Templates?</h2><h3 id="What-is-templates"><a href="#What-is-templates" class="headerlink" title="What is templates?"></a>What is templates?</h3><blockquote><p>Templates are the fundation for generic programming in C++. A template is a blueprint or formula for creating classes or functions. </p></blockquote><h3 id="Why-we-need-templates"><a href="#Why-we-need-templates" class="headerlink" title="Why we need templates?"></a>Why we need templates?</h3><p>Sometimes we need to write different version of the same function or classfor different types, which will make our code fat. Thus we need templates help us solving this. </p><h3 id="How-templates-work"><a href="#How-templates-work" class="headerlink" title="How templates work?"></a>How templates work?</h3><p>Relys on type parameterization, compiler would bind, either implicitly or explicitly, template argument(s) to the template parameter(s) to generate specific function or class.</p><h2 id="Function-templates"><a href="#Function-templates" class="headerlink" title="Function templates"></a>Function templates</h2><p>A function template represents a group of functions which have the same functionality. We also can treat a function template as a formula which could be used to generate type-specific version of that function and this will be done by the compiler. </p><blockquote><p>When the compiler sees the definition of a template, it does not generate code. It genreates code only when we instantiate a specific instance of the template.</p></blockquote><p>Thus when we using a template, we need to know the definition of the template, which means when compiler need to instantiate a template, it must can see the code that defines a function template or class template member function. This is different to ordinary function. </p><blockquote><p>Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarity, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class defintions and function declarations in header files adn definitions of ordinary and class-member functions in source files. </p></blockquote><p><strong>Thus, definitions of function templates and member functions of class templates are ordinarily put into header files.</strong></p><h3 id="Usage-of-a-function-template"><a href="#Usage-of-a-function-template" class="headerlink" title="Usage of a function template"></a>Usage of a function template</h3><h4 id="1-The-Definition-Of-a-Function-Template"><a href="#1-The-Definition-Of-a-Function-Template" class="headerlink" title="1. The Definition Of a Function Template"></a>1. The Definition Of a Function Template</h4><p>It should looks like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; x, T <span class="keyword">const</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>A template definition starts with the keyword <em>template</em> followed by a <strong>template parameter list</strong>, which is a comma-separated list of one or more <strong>template parameters</strong> bracketed by the less-than(&lt;) and greater-than(&gt;) tokens. In a template definition, the template parameter list cannot be empty. </p></blockquote><p><strong>Template parameter list</strong> can take <strong>type parameter</strong> and <strong>nontype parameter</strong>. </p><ol><li><strong>type parameter</strong><br> A type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body. Each type parameter must be preceded by the keyword <em>class</em> or <em>typename</em>.  </li><li><p><strong>nontype parameter</strong><br> A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the <em>class</em> or <em>typename</em> keyword. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>A nontype parameter may be integral type, or a pointer or (lvalue)reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression. Arguments bound to a pointer or reference nontype parameter must have static lifetime. </p></blockquote><h4 id="2-Instantiating-a-Function-Template"><a href="#2-Instantiating-a-Function-Template" class="headerlink" title="2. Instantiating a Function Template"></a>2. Instantiating a Function Template</h4><p>There are two ways to instantiate a function template, and the type used to instantiate the template must satisfy the operation of that type inside the definition of that function template:</p><ol><li>Explicit way:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; max&lt;<span class="keyword">int</span>&gt;(<span class="number">123</span>, <span class="number">234</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>Implicit way</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; max(<span class="number">234</span>,<span class="number">567</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="Class-templates"><a href="#Class-templates" class="headerlink" title="Class templates"></a>Class templates</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Templates&quot;&gt;&lt;a href=&quot;#Templates&quot; class=&quot;headerlink&quot; title=&quot;Templates?&quot;&gt;&lt;/a&gt;Templates?&lt;/h2&gt;&lt;h3 id=&quot;What-is-templates&quot;&gt;&lt;a href=&quot;#What-i
      
    
    </summary>
    
      <category term="C++" scheme="https://gorillasx.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://gorillasx.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s get started</title>
    <link href="https://gorillasx.github.io/2018/03/01/Let-s-get-started/"/>
    <id>https://gorillasx.github.io/2018/03/01/Let-s-get-started/</id>
    <published>2018-03-01T07:10:43.000Z</published>
    <updated>2018-03-01T07:11:27.000Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Let’s-get-started"><a href="#Let’s-get-started" class="headerlink" title="Let’s get started"></a>Let’s get started</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Let’s-get-started&quot;&gt;&lt;a href=&quot;#Let’s-get-started&quot; class=&quot;headerlink&quot; title=&quot;Let’s get started&quot;&gt;&lt;/a&gt;Let’s get started&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
