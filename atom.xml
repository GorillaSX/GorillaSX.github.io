<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Xin Song</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://gorillasx.github.io/"/>
  <updated>2018-06-20T13:22:14.497Z</updated>
  <id>https://gorillasx.github.io/</id>
  
  <author>
    <name>Xin Song</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Preparing For Interview - Day 1</title>
    <link href="https://gorillasx.github.io/2018/06/19/Preparing-For-Interview-Day-1/"/>
    <id>https://gorillasx.github.io/2018/06/19/Preparing-For-Interview-Day-1/</id>
    <published>2018-06-19T12:58:42.000Z</published>
    <updated>2018-06-20T13:22:14.497Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Somthing-New"><a href="#1-Somthing-New" class="headerlink" title="1. Somthing New"></a>1. Somthing New</h3><h4 id="1-Leetcode-690-EmployeeImportance"><a href="#1-Leetcode-690-EmployeeImportance" class="headerlink" title="1. Leetcode 690.EmployeeImportance"></a>1. <a href="https://leetcode.com/problems/employee-importance/description/" target="_blank" rel="noopener">Leetcode 690.EmployeeImportance</a></h4><p>You are given a data structure of employee information, which includes the employee’s unique id, his importance value and his direct subordinates’ id.<br>For example, employee 1 is the leader of employee 2, and employee 2 is the leader of employee 3. They have importance value 15, 10 and 5, respectively. Then employee 1 has a data structure like [1, 15, [2]], and employee 2 has [2, 10, [3]], and employee 3 has [3, 5, []]. Note that although employee 3 is also a subordinate of employee 1, the relationship is not direct.<br>Now given the employee information of a company, and an employee id, you need to return the total importance value of this employee and all his subordinates.</p><blockquote><p>Example 1:<br>Input: [[1, 5, [2, 3]], [2, 3, []], [3, 3, []]], 1<br>Output: 11<br>Explanation:<br>Employee 1 has importance value 5, and he has two direct subordinates: employee 2 and employee 3. They both have importance value 3. So the total importance value of employee 1 is 5 + 3 + 3 = 11.<br>Note:<br>One employee has at most one direct leader and may have several subordinates.<br>The maximum number of employees won’t exceed 2000.</p></blockquote><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">// Employee info</span></span><br><span class="line"><span class="comment">class Employee &#123;</span></span><br><span class="line"><span class="comment">public:</span></span><br><span class="line"><span class="comment">    // It's the unique ID of each node.</span></span><br><span class="line"><span class="comment">    // unique id of this employee</span></span><br><span class="line"><span class="comment">    int id;</span></span><br><span class="line"><span class="comment">    // the importance value of this employee</span></span><br><span class="line"><span class="comment">    int importance;</span></span><br><span class="line"><span class="comment">    // the id of direct subordinates</span></span><br><span class="line"><span class="comment">    vector&lt;int&gt; subordinates;</span></span><br><span class="line"><span class="comment">&#125;;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getImportance</span><span class="params">(<span class="built_in">vector</span>&lt;Employee*&gt; employees, <span class="keyword">int</span> id)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, Employee*&gt; employeeMap;</span><br><span class="line">        <span class="keyword">for</span>(Employee* Employee : employees)</span><br><span class="line">            employeeMap[Employee-&gt;id] = Employee;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="keyword">int</span>&gt; start;</span><br><span class="line">        start.push(id);</span><br><span class="line">        <span class="keyword">int</span> totalScore = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!start.empty())</span><br><span class="line">        &#123;</span><br><span class="line">           <span class="keyword">int</span> id = start.front(); start.pop();</span><br><span class="line">           totalScore += employeeMap[id]-&gt;importance;  </span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span>&amp; sub : employeeMap[id]-&gt;subordinates)  </span><br><span class="line">           &#123;</span><br><span class="line">               start.push(sub);</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> totalScore;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-107-Binary-Tree-Level-Order-Traverse-2"><a href="#2-Leetcode-107-Binary-Tree-Level-Order-Traverse-2" class="headerlink" title="2. Leetcode 107.Binary Tree Level Order Traverse 2"></a>2. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/" target="_blank" rel="noopener">Leetcode 107.Binary Tree Level Order Traverse 2</a></h4><p>Given a binary tree, return the bottom-up level order traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">             <span class="keyword">return</span>  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; curLevel; </span><br><span class="line">        curLevel.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!curLevel.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = curLevel.size();</span><br><span class="line">            result.push_back(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = curLevel.front(); curLevel.pop();</span><br><span class="line">                result.back().push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) curLevel.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) curLevel.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(result.begin(), result.end());</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Solution two</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">TraverseToGetHeight</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curHeight, <span class="keyword">int</span>&amp; height)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        TraverseToGetHeight(root-&gt;left,  curHeight + <span class="number">1</span>, height);</span><br><span class="line">        height = max(height, curHeight);</span><br><span class="line">        TraverseToGetHeight(root-&gt;right, curHeight + <span class="number">1</span>, height);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">             <span class="keyword">return</span>  <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;();</span><br><span class="line">        <span class="keyword">int</span> height = <span class="number">0</span>;</span><br><span class="line">        TraverseToGetHeight(root, <span class="number">1</span>, height);</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; result(height, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;());</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; curLevel; </span><br><span class="line">        curLevel.push(root);</span><br><span class="line">        <span class="keyword">int</span> level = height - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!curLevel.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> size = curLevel.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = curLevel.front(); curLevel.pop();</span><br><span class="line">                result[level].push_back(node-&gt;val);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) curLevel.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) curLevel.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            level--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-111-Minimum-Depth-Of-Binary-Tree"><a href="#3-Leetcode-111-Minimum-Depth-Of-Binary-Tree" class="headerlink" title="3. Leetcode 111.Minimum Depth Of Binary Tree"></a>3. <a href="https://leetcode.com/problems/minimum-depth-of-binary-tree/description/" target="_blank" rel="noopener">Leetcode 111.Minimum Depth Of Binary Tree</a></h4><p>Given a binary tree, find its minimum depth.</p><p>The minimum depth is the number of nodes along the shortest path from the root node down to the nearest leaf node.</p><p>Note: A leaf is a node with no children.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="comment">//Solution One: Brute Force O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> depth = INT_MAX;</span><br><span class="line">        minDepth(root, <span class="number">1</span>, depth);</span><br><span class="line">        <span class="keyword">return</span> depth; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">minDepth</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curDepth, <span class="keyword">int</span>&amp; depth)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">           &#123;</span><br><span class="line">               depth = min(depth, curDepth);</span><br><span class="line">               <span class="keyword">return</span>; </span><br><span class="line">           &#125;</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;left)  minDepth(root-&gt;left, curDepth + <span class="number">1</span>,  depth);</span><br><span class="line">           <span class="keyword">if</span>(root-&gt;right) minDepth(root-&gt;right, curDepth + <span class="number">1</span>, depth);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two: BFS, better then O(n)</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minDepth</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="literal">NULL</span> == root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; levels;</span><br><span class="line">        levels.push(root);</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(!levels.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = levels.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">               TreeNode* node = levels.front(); levels.pop();</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left == <span class="literal">NULL</span> &amp;&amp; node-&gt;right == <span class="literal">NULL</span>)</span><br><span class="line">                    <span class="keyword">return</span> level;  </span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) levels.push(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) levels.push(node-&gt;right);  </span><br><span class="line">            &#125;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-513-Find-Bottom-Left-Tree-Value"><a href="#4-Leetcode-513-Find-Bottom-Left-Tree-Value" class="headerlink" title="4. Leetcode 513.Find Bottom Left Tree Value"></a>4. <a href="https://leetcode.com/problems/find-bottom-left-tree-value/description/" target="_blank" rel="noopener">Leetcode 513.Find Bottom Left Tree Value</a></h4><p>Given a binary tree, find the leftmost value in the last row of the tree.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution one, O(n) Brute Force, Two Pass Traverse</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FindLevel</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curL, <span class="keyword">int</span>&amp; level)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        FindLevel(root-&gt;left, curL + <span class="number">1</span>, level);</span><br><span class="line">        level = max(level, curL);</span><br><span class="line">        FindLevel(root-&gt;right, curL + <span class="number">1</span>, level);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetValue</span><span class="params">(TreeNode* root, <span class="keyword">int</span> curl, <span class="keyword">int</span> level, <span class="keyword">int</span>&amp; value, <span class="keyword">bool</span>&amp; find)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(root)</span><br><span class="line">    &#123;</span><br><span class="line">        GetValue(root-&gt;left, curl + <span class="number">1</span>, level, value, find);</span><br><span class="line">        <span class="keyword">if</span>(find)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="keyword">if</span>(curl == level &amp;&amp; !find)</span><br><span class="line">        &#123;</span><br><span class="line">            value = root-&gt;val;</span><br><span class="line">            find = <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        GetValue(root-&gt;right, curl + <span class="number">1</span>, level, value, find);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> level = <span class="number">0</span>;</span><br><span class="line">        FindLevel(root, <span class="number">0</span>, level);</span><br><span class="line">        <span class="keyword">int</span> value = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">bool</span> find = <span class="literal">false</span>;</span><br><span class="line">        GetValue(root, <span class="number">0</span>, level, value, find);</span><br><span class="line">        <span class="keyword">return</span> value; </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution Two, BFS, O(n) one pass traverse</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">findBottomLeftValue</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">        level.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!level.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            result = level.front()-&gt;val;</span><br><span class="line">            <span class="keyword">size_t</span> size = level.size();</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                TreeNode* node = level.front(); level.pop();</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;left) level.push(node-&gt;left);</span><br><span class="line">                <span class="keyword">if</span>(node-&gt;right) level.push(node-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="5-Leetcode-515-Find-Largest-Value-In-Each-Tree-Row"><a href="#5-Leetcode-515-Find-Largest-Value-In-Each-Tree-Row" class="headerlink" title="5. Leetcode 515.Find Largest Value In Each Tree Row"></a>5. <a href="https://leetcode.com/problems/find-largest-value-in-each-tree-row/description/" target="_blank" rel="noopener">Leetcode 515.Find Largest Value In Each Tree Row</a></h4><p>You need to find the largest value in each row of a binary tree.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * struct TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode *left;</span></span><br><span class="line"><span class="comment"> *     TreeNode *right;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) : val(x), left(NULL), right(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; largestValues(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; results;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode*&gt; level;</span><br><span class="line">        <span class="keyword">if</span>(root)</span><br><span class="line">            level.push(root);</span><br><span class="line">        <span class="keyword">while</span>(!level.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">size_t</span> size = level.size();</span><br><span class="line">            <span class="keyword">int</span> maxValue = INT_MIN;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; size;i++)</span><br><span class="line">            &#123;</span><br><span class="line">               TreeNode* node = level.front(); level.pop();</span><br><span class="line">               maxValue = max(maxValue, node-&gt;val);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;left) level.push(node-&gt;left);</span><br><span class="line">               <span class="keyword">if</span>(node-&gt;right) level.push(node-&gt;right);   </span><br><span class="line">            &#125;</span><br><span class="line">            results.push_back(maxValue);</span><br><span class="line">        &#125;   </span><br><span class="line">        <span class="keyword">return</span> results;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="6-Leetcode-529-Minesweeper"><a href="#6-Leetcode-529-Minesweeper" class="headerlink" title="6. Leetcode 529. Minesweeper!"></a>6. <a href="Let&#39;s play the minesweeper game (Wikipedia, online game">Leetcode 529. Minesweeper</a>!</h4><p>You are given a 2D char matrix representing the game board. ‘M’ represents an unrevealed mine, ‘E’ represents an unrevealed empty square, ‘B’ represents a revealed blank square that has no adjacent (above, below, left, right, and all 4 diagonals) mines, digit (‘1’ to ‘8’) represents how many mines are adjacent to this revealed square, and finally ‘X’ represents a revealed mine.</p><p>Now given the next click position (row and column indices) among all the unrevealed squares (‘M’ or ‘E’), return the board after revealing this position according to the following rules:</p><p>If a mine (‘M’) is revealed, then the game is over - change it to ‘X’.<br>If an empty square (‘E’) with no adjacent mines is revealed, then change it to revealed blank (‘B’) and all of its adjacent unrevealed squares should be revealed recursively.<br>If an empty square (‘E’) with at least one adjacent mine is revealed, then change it to a digit (‘1’ to ‘8’) representing the number of adjacent mines.<br>Return the board when no more squares will be revealed.)</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt; updateBoard(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; board, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; click) &#123;</span><br><span class="line">        <span class="keyword">if</span>(board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] == <span class="string">'M'</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            board[click[<span class="number">0</span>]][click[<span class="number">1</span>]] = <span class="string">'X'</span>;</span><br><span class="line">            <span class="keyword">return</span> board;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> m = board.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? board[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; clicks;</span><br><span class="line">        clicks.push(click);</span><br><span class="line">        <span class="keyword">while</span>(!clicks.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; c = clicks.front(); clicks.pop();</span><br><span class="line">            <span class="keyword">int</span> row = c[<span class="number">0</span>], col = c[<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> mineCount = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">-1</span>; j &lt; <span class="number">2</span>;j++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">int</span> r = row + i;</span><br><span class="line">                    <span class="keyword">int</span> c = col + j;</span><br><span class="line">                    <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; board[r][c] == <span class="string">'M'</span>)</span><br><span class="line">                        mineCount++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(mineCount != <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                board[row][col] = <span class="string">'0'</span> + mineCount;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">-1</span>;i &lt; <span class="number">2</span>;i++)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">-1</span>;j &lt; <span class="number">2</span>;j++)</span><br><span class="line">                    &#123;</span><br><span class="line">                        <span class="keyword">int</span> r = row + i;</span><br><span class="line">                        <span class="keyword">int</span> c = col + j;</span><br><span class="line">                        <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; board[r][c] == <span class="string">'E'</span>)</span><br><span class="line">                        &#123;</span><br><span class="line">                            board[r][c] = <span class="string">'B'</span>;</span><br><span class="line">                            clicks.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;r, c&#125;));</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;        </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> board;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="2-Review"><a href="#2-Review" class="headerlink" title="2. Review"></a>2. Review</h3><h4 id="1-Leetcode-732-My-Calender-3"><a href="#1-Leetcode-732-My-Calender-3" class="headerlink" title="1. Leetcode 732. My Calender 3"></a>1. <a href="https://leetcode.com/problems/my-calendar-iii/description/" target="_blank" rel="noopener">Leetcode 732. My Calender 3</a></h4><blockquote><p>Implement a MyCalendarThree class to store your events. A new event can always be added.<br>Your class will have one method, book(int start, int end). Formally, this represents a booking on the half open interval [start, end), the range of real numbers x such that start &lt;= x &lt; end.<br>A K-booking happens when K events have some non-empty intersection (ie., there is some time that is common to all K events.)<br>For each call to the method MyCalendar.book, return an integer K representing the largest integer such that there exists a K-booking in the calendar.<br>Your class will be called like this: MyCalendarThree cal = new MyCalendarThree(); MyCalendarThree.book(start, end)</p></blockquote><p><strong>Thought:</strong><br>Every time, after inserting a new event, the largest K-book in the calender, need to be updated or not. Every time, when we have a new event, we want to know, where should we insert this event in, just like searching a right place. So the key point is how to make this searching efficient. If we can keep the events we have meet in some order according to there start time. Then we could use binary search to find a right place efficiently. So far, we want to build a binary search tree, then what should the node looks like in this binary search tree. It should have be used to represent a time slot, with a start time, and end time, and a counter used to count how many events overlaps with this time slot. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">STreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> start, end, count;</span><br><span class="line">    STreeNode* left, * right;</span><br><span class="line">    STreeNode(<span class="keyword">int</span> s, <span class="keyword">int</span> e, <span class="keyword">int</span> c = <span class="number">1</span>):start(s), end(e), count(c), left(<span class="literal">NULL</span>), right(<span class="literal">NULL</span>)&#123;&#125;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">insert</span><span class="params">(STreeNode*&amp; root)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            root = <span class="keyword">this</span>;</span><br><span class="line">            <span class="keyword">return</span> root-&gt;count;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(start &gt;= root-&gt;end)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;insert(root-&gt;right);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(end &lt;= root-&gt;start)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>-&gt;insert(root-&gt;left);</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> leftreturn = <span class="number">0</span>, rightreturn = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span>(start &lt; root-&gt;start)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newleft = <span class="keyword">new</span> STreeNode(start, root-&gt;start, count);</span><br><span class="line">                leftreturn = newleft-&gt;insert(root-&gt;left);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(start &gt; root-&gt;start)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newleft = <span class="keyword">new</span> STreeNode(root-&gt;start, start, root-&gt;count);</span><br><span class="line">                newleft-&gt;left = root-&gt;left;</span><br><span class="line">                root-&gt;left = newleft;</span><br><span class="line">                root-&gt;start = start;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span>(end &gt; root-&gt;end)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newright = <span class="keyword">new</span> STreeNode(root-&gt;end, end, count);</span><br><span class="line">                rightreturn = newright-&gt;insert(root-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(end &lt; root-&gt;end)</span><br><span class="line">            &#123;</span><br><span class="line">                STreeNode* newright = <span class="keyword">new</span> STreeNode(end, root-&gt;end, root-&gt;count);</span><br><span class="line">                newright-&gt;right = root-&gt;right;</span><br><span class="line">                root-&gt;right = newright;</span><br><span class="line">                root-&gt;end = end;</span><br><span class="line">            &#125;</span><br><span class="line">            ++(root-&gt;count);</span><br><span class="line">            <span class="keyword">return</span> max(leftreturn, max(rightreturn, root-&gt;count));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ~STreeNode()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(left)</span><br><span class="line">            <span class="keyword">delete</span> left;</span><br><span class="line">        <span class="keyword">if</span>(right)</span><br><span class="line">            <span class="keyword">delete</span> right;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyCalendarThree</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    STreeNode* root;</span><br><span class="line">    <span class="keyword">int</span> curMax;</span><br><span class="line">    MyCalendarThree(<span class="keyword">void</span>):root(<span class="literal">NULL</span>), curMax(<span class="number">0</span>)&#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">book</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        STreeNode* node = <span class="keyword">new</span> STreeNode(start, end);</span><br><span class="line">        <span class="keyword">int</span> count = node-&gt;insert(root);</span><br><span class="line">        curMax = max(curMax, count);</span><br><span class="line">        <span class="keyword">return</span> curMax;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    ~MyCalendarThree()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">delete</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="2-Leetcode-765-Couples-Holding-Hands"><a href="#2-Leetcode-765-Couples-Holding-Hands" class="headerlink" title="2. Leetcode 765. Couples Holding Hands"></a>2. <a href="https://leetcode.com/problems/couples-holding-hands/description/" target="_blank" rel="noopener">Leetcode 765. Couples Holding Hands</a></h4><blockquote><p>N couples sit in 2N seats arranged in a row and want to hold hands. We want to know the minimum number of swaps so that every couple is sitting side by side. A swap consists of choosing any two people, then they stand up and switch seats.<br>The people and seats are represented by an integer from 0 to 2N-1, the couples are numbered in order, the first couple being (0, 1), the second couple being (2, 3), and so on with the last couple being (2N-2, 2N-1).<br>The couples’ initial seating is given by row[i] being the value of the person who is initially sitting in the i-th seat.</p></blockquote><p><strong>Thought:</strong><br>2N seats, N couples, we treat every two adjacent seats as a node, and two nodes could be connected if there is a valid swap, a valid swap means, after swapping two people, we can make at least one couple sitting together. Nodes connected by those valid swaps, then N nodes were grouped into several components. what we want to do to is cutting edges, doing swaps, then generating N isolated nodes. One fact we need to know is each swapping, we can only generate one more isolated node. Then, if we have a connected components, and want to generate b nodes, we only need to do b - a times swapping.</p><p>Another way to solve this question is, for each invalid node, which means the people sitting in this node is not a couple. Then we have two swapping choices to make it valid. If we think deeply, those two choices have same effect, which means, no matter we choose which choice, we can reach same result.<br>Then this problem can be solved by Greedy. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one: Union Find </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size() / <span class="number">2</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PersonToNode(row.size(), <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            PersonToNode[row[i]] = i / <span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; parents(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            parents[i] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> components = n;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left  = i / <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">int</span> right = (row[i] % <span class="number">2</span> == <span class="number">0</span> ? PersonToNode[row[i]+<span class="number">1</span>] : PersonToNode(row[i] - <span class="number">1</span>));</span><br><span class="line">            <span class="keyword">if</span>(left == right)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">while</span>(parent[left] != left)</span><br><span class="line">                left = parent[left];</span><br><span class="line">            <span class="keyword">while</span>(parent[right] != right)</span><br><span class="line">                right = parent[right];</span><br><span class="line">            <span class="keyword">if</span>(left != right)</span><br><span class="line">            &#123;</span><br><span class="line">                parent[left] = right;</span><br><span class="line">                components--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n - components;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//Greedy </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minSwapsCouples</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; row)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n = row.size();</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; PersonToNode(n, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i++)</span><br><span class="line">            PersonToNode[row[i]] = i;</span><br><span class="line">        <span class="keyword">int</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>;i &lt; row.size();i+=<span class="number">2</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> left = row[i];</span><br><span class="line">            <span class="keyword">int</span> right = row[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">int</span> target = row[i] % <span class="number">2</span> != <span class="number">0</span> ? row[i] - <span class="number">1</span> : row[i] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">if</span>(right == target) </span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            row[i+<span class="number">1</span>] = target;</span><br><span class="line">            PersonToNode[right] = PersonToNode[target];</span><br><span class="line">            row[PersonToNode[right]] = right;</span><br><span class="line">            count++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> count;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="3-Leetcode-302-Smallest-Rectangle-Enclosing-Black-Pixels"><a href="#3-Leetcode-302-Smallest-Rectangle-Enclosing-Black-Pixels" class="headerlink" title="3. Leetcode 302. Smallest Rectangle Enclosing Black Pixels"></a>3. <a href="https://leetcode.com/problems/smallest-rectangle-enclosing-black-pixels/description/" target="_blank" rel="noopener">Leetcode 302. Smallest Rectangle Enclosing Black Pixels</a></h4><blockquote><p>An image is represented by a binary matrix with 0 as a white pixel and 1 as a black pixel. The black pixels are connected, i.e., there is only one black region. Pixels are connected horizontally and vertically. Given the location (x, y) of one of the black pixels, return the area of the smallest (axis-aligned) rectangle that encloses all black pixels.</p></blockquote><p><strong>Thought:</strong><br>We are given an Image, and asked for a rectangle. So we need to think about how to represent a rectangle in an Image? A rectangle can be represented by two coordinates, left-bottom and right-top corner. It also can be represented by a point, corner or midpoint,  and the length of two different dimensions. For this problem, start from given black pixel, we can do Breath-first-search, to traverse every black pixel, and collect left-most, right-most, bottom-most, top-most information, which could be used to represent a rectangle. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">minArea</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;&gt;&amp; image, <span class="keyword">int</span>&amp; x, <span class="keyword">int</span>&amp; y)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = image.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? image[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = n - <span class="number">1</span>, right = <span class="number">0</span>, top = m - <span class="number">1</span>, bot = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">        visited[x][y] = <span class="literal">true</span>;</span><br><span class="line">        <span class="built_in">queue</span>&lt;pair&lt;<span class="keyword">int</span>,<span class="keyword">int</span>&gt;&gt; pixels;</span><br><span class="line">        pixels.emplace(x, y);</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">while</span>(!pixels.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> row = pixels.front().first;</span><br><span class="line">            <span class="keyword">int</span> col = pixels.front().second;</span><br><span class="line">            pixels.pop();</span><br><span class="line">            left = min(left, col);</span><br><span class="line">            right = max(right, col);</span><br><span class="line">            top = min(top, row);</span><br><span class="line">            bot = max(bot, row);</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = row + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = col + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; n &amp;&amp; visited[r][c] == <span class="literal">false</span> &amp;&amp; image[r][c] == <span class="string">'1'</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[r][c] =<span class="literal">true</span>;</span><br><span class="line">                    pixels.emplace(r,c);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> (right - left + <span class="number">1</span>) * (bot - top + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h4 id="4-Leetcode-778-Swim-in-Rising-Water"><a href="#4-Leetcode-778-Swim-in-Rising-Water" class="headerlink" title="4. Leetcode 778. Swim in Rising Water"></a>4. <a href="https://leetcode.com/problems/swim-in-rising-water/description/" target="_blank" rel="noopener">Leetcode 778. Swim in Rising Water</a></h4><blockquote><p>On an N x N grid, each square grid[i][j] represents the elevation at that point (i,j).</p></blockquote><p>Now rain starts to fall. At time t, the depth of the water everywhere is t. You can swim from a square to another 4-directionally adjacent square if and only if the elevation of both squares individually are at most t. You can swim infinite distance in zero time. Of course, you must stay within the boundaries of the grid during your swim.</p><p>You start at the top left square (0, 0). What is the least time until you can reach the bottom right square (N-1, N-1)?</p><p><strong>Thought:</strong></p><p><em>Binary Search + DFS</em><br>At time t, the position that the depth of the water smaller that t, would be t. You can swim infinite distance in zero time if the start position and destination have same elevation. So we start at (0,0) and want to swim to (n-1, n-1), what’s the least time? There are many paths from (0,0) to (n-1, n-1), the highest elevation on each path will be the time that could make this path work. If we use the highest elevation on each path to score each path. Then we need to find a path with smallest score. Because we know the possible range of those scores, then we could do binary search to find the smallest score path. We could use Depth-First-Search to check whether at this time, we can reach (n - 1, n - 1)</p><p><em>Heap</em><br>At each position, we have four direction to move, how to choice next step will be the key point, because we can swim to any position in zero time, then the positions we have meet before all could be the next move. Therefore, we could use a minHeap to store all the position we can reach in next move, then every time when we want to move, we could find the position with lowest elevation to move, at the same time we want to record the highest elevation on this path until we reach (n-1, n-1). Since every time, we select a position from all reachable position which has lowest elevation, then the path from (0, 0) to (n-1, n-1) will be the path with smallest score. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Solution one, Binary Search + DFS </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> n = m ? grid[<span class="number">0</span>].size() : <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> left = grid[<span class="number">0</span>][<span class="number">0</span>], right = m * m <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> mid = (left + (right - left)/ <span class="number">2</span>);</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt; visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(n, <span class="literal">false</span>));</span><br><span class="line">            visited[<span class="number">0</span>][<span class="number">0</span>]= <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span>(DFSCheck(grid, visited, mid, <span class="number">0</span>, <span class="number">0</span>, m - <span class="number">1</span>, m <span class="number">-1</span>))</span><br><span class="line">                right = mid;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">DFSCheck</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;&amp; visited, <span class="keyword">int</span> time, <span class="keyword">int</span> curRow, <span class="keyword">int</span> curCol , <span class="keyword">int</span> targetRow, <span class="keyword">int</span> targetCol)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(curRow == targetRow &amp;&amp; curCol == targetCol)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> r = curRow + delta[i];</span><br><span class="line">            <span class="keyword">int</span> c = curCol + delta[i+<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt;= targetRow &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt;= targetCol &amp;&amp; visited[r][c] == <span class="literal">false</span> &amp;&amp; grid[r][c] &lt;= time)</span><br><span class="line">            &#123;</span><br><span class="line">                visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                <span class="keyword">if</span>(DFSCheck(grid, visited, time, r, c, targetRow, targetCol))</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//Solution two: Heap </span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">comp</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; lhs, <span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; rhs)</span> <span class="keyword">const</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> lhs[<span class="number">0</span>] &gt; rhs[<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">typedef</span> priority_queue&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;, <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;, comp&gt; vectorMinHeap;</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">swimInWater</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt;&amp; grid)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> delta[<span class="number">5</span>] = &#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;</span><br><span class="line">        <span class="keyword">int</span> m = grid.size();</span><br><span class="line">        <span class="keyword">int</span> result = <span class="number">0</span>;</span><br><span class="line">        vectorMinHeap nextMove;</span><br><span class="line">        nextMove.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;grid[<span class="number">0</span>][<span class="number">0</span>], <span class="number">0</span>,<span class="number">0</span>&#125;));</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;&gt;  visited(m, <span class="built_in">vector</span>&lt;<span class="keyword">bool</span>&gt;(m, <span class="literal">false</span>));</span><br><span class="line">        visited[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; move = nextMove.top();</span><br><span class="line">            nextMove.pop();</span><br><span class="line">            result = max(result, move[<span class="number">0</span>]);</span><br><span class="line">            <span class="keyword">if</span>(move[<span class="number">1</span>] == m <span class="number">-1</span> &amp;&amp; move[<span class="number">2</span>] == m <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; <span class="number">4</span>;i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> r = move[<span class="number">1</span>] + delta[i];</span><br><span class="line">                <span class="keyword">int</span> c = move[<span class="number">2</span>] + delta[i+<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(r &gt;= <span class="number">0</span> &amp;&amp; r &lt; m &amp;&amp; c &gt;= <span class="number">0</span> &amp;&amp; c &lt; m &amp;&amp; visited[r][c] == <span class="literal">false</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[r][c] = <span class="literal">true</span>;</span><br><span class="line">                    nextMove.push(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;(&#123;grid[r][c], r, c&#125;));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Somthing-New&quot;&gt;&lt;a href=&quot;#1-Somthing-New&quot; class=&quot;headerlink&quot; title=&quot;1. Somthing New&quot;&gt;&lt;/a&gt;1. Somthing New&lt;/h3&gt;&lt;h4 id=&quot;1-Leetcode-690-
      
    
    </summary>
    
      <category term="Data Structure And Algorithm" scheme="https://gorillasx.github.io/categories/Data-Structure-And-Algorithm/"/>
    
    
      <category term="interview" scheme="https://gorillasx.github.io/tags/interview/"/>
    
      <category term="leetcode problem solution" scheme="https://gorillasx.github.io/tags/leetcode-problem-solution/"/>
    
      <category term="data structure" scheme="https://gorillasx.github.io/tags/data-structure/"/>
    
      <category term="algorithm" scheme="https://gorillasx.github.io/tags/algorithm/"/>
    
  </entry>
  
  <entry>
    <title>Algorithm collections</title>
    <link href="https://gorillasx.github.io/2018/04/26/Algorithm-collections/"/>
    <id>https://gorillasx.github.io/2018/04/26/Algorithm-collections/</id>
    <published>2018-04-26T21:13:49.000Z</published>
    <updated>2018-04-26T22:05:23.596Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Boyer-Moore-Algorithm"><a href="#1-Boyer-Moore-Algorithm" class="headerlink" title="1. Boyer-Moore Algorithm"></a>1. <a href="https://gregable.com/2013/10/majority-vote-algorithm-find-majority.html" target="_blank" rel="noopener">Boyer-Moore Algorithm</a></h3><p><strong>Description:</strong><br>Find the majority element in a list of values. This algorithm could be done in parallel.<br>Time complexity: O(n)<br>Spcae complexity: O(1)<br><strong>How it works:</strong><br>It required exactly 2 passes over the input list. </p><ol><li><p>In the first pass, we need to record a <em>candidate</em>, and the <em>count</em> of the <em>candicate</em>. At begining, <em>count</em> equal to 0, <em>candidate</em> could be any value.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">candidate = <span class="number">0</span></span><br><span class="line">count = <span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> input:</span><br><span class="line">    <span class="keyword">if</span> count == <span class="number">0</span>:</span><br><span class="line">        candidate = value</span><br><span class="line">    <span class="keyword">if</span> candidate == value:</span><br><span class="line">        count += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span> :</span><br><span class="line">        count -= <span class="number">1</span></span><br></pre></td></tr></table></figure></li><li><p>Check whether this candidate is the majority element.</p></li></ol><p><strong>Explanation:</strong><br>At each point, where count == 0, means before that there are no elements exist or each element could find an another value to pair, to neutralize it. Thus, candidates before cannot be the majority element. But it also cannot guarantee the candidate we will get  at the end of traversal will me the majorith element, which is the reason we need a second pass. </p><p><strong>Practice:</strong><br><a href="https://leetcode.com/problems/majority-element/description/" target="_blank" rel="noopener">169. Majority Element</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1-Boyer-Moore-Algorithm&quot;&gt;&lt;a href=&quot;#1-Boyer-Moore-Algorithm&quot; class=&quot;headerlink&quot; title=&quot;1. Boyer-Moore Algorithm&quot;&gt;&lt;/a&gt;1. &lt;a href=&quot;http
      
    
    </summary>
    
      <category term="Algorithm" scheme="https://gorillasx.github.io/categories/Algorithm/"/>
    
    
      <category term="Algorithm" scheme="https://gorillasx.github.io/tags/Algorithm/"/>
    
  </entry>
  
  <entry>
    <title>RNN</title>
    <link href="https://gorillasx.github.io/2018/04/12/RNN/"/>
    <id>https://gorillasx.github.io/2018/04/12/RNN/</id>
    <published>2018-04-13T00:41:38.000Z</published>
    <updated>2018-04-13T20:26:36.461Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Examples-of-RNN-architectures"><a href="#Examples-of-RNN-architectures" class="headerlink" title="Examples of RNN architectures"></a>Examples of RNN architectures</h3><h4 id="Many-to-Many-architecture"><a href="#Many-to-Many-architecture" class="headerlink" title="Many-to-Many architecture"></a>Many-to-Many architecture</h4><ol><li>Input length == Output length</li><li>Input length != Output length<h4 id="Many-to-One-architecture"><a href="#Many-to-One-architecture" class="headerlink" title="Many-to-One architecture"></a>Many-to-One architecture</h4>sentiment classification</li></ol><h4 id="One-to-Many-architecture"><a href="#One-to-Many-architecture" class="headerlink" title="One-to-Many architecture"></a>One-to-Many architecture</h4><p>Music generation</p><h3 id="Language-model-and-sequence-generation"><a href="#Language-model-and-sequence-generation" class="headerlink" title="Language model and sequence generation"></a>Language model and sequence generation</h3><h4 id="What-is-language-modelling"><a href="#What-is-language-modelling" class="headerlink" title="What is language modelling?"></a>What is language modelling?</h4><h4 id="language-modelling-with-an-RNN"><a href="#language-modelling-with-an-RNN" class="headerlink" title="language modelling with an RNN"></a>language modelling with an RNN</h4><p>Training set: large corpus of english text<br>Tokenize the sentences </p><h3 id="Vanishing-Gradient-problem"><a href="#Vanishing-Gradient-problem" class="headerlink" title="Vanishing Gradient problem"></a>Vanishing Gradient problem</h3><h3 id="Gated-Recurrent-Unit"><a href="#Gated-Recurrent-Unit" class="headerlink" title="Gated Recurrent Unit"></a>Gated Recurrent Unit</h3><p>It allows you to learn very long range connections in a sequecnce.</p><h3 id="LSTM"><a href="#LSTM" class="headerlink" title="LSTM"></a>LSTM</h3><h3 id="Bidirectional-RNN"><a href="#Bidirectional-RNN" class="headerlink" title="Bidirectional RNN"></a>Bidirectional RNN</h3><h3 id="Deep-RNNs"><a href="#Deep-RNNs" class="headerlink" title="Deep RNNs"></a>Deep RNNs</h3>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Examples-of-RNN-architectures&quot;&gt;&lt;a href=&quot;#Examples-of-RNN-architectures&quot; class=&quot;headerlink&quot; title=&quot;Examples of RNN architectures&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="Deep Learning" scheme="https://gorillasx.github.io/categories/Deep-Learning/"/>
    
      <category term="RNN" scheme="https://gorillasx.github.io/categories/Deep-Learning/RNN/"/>
    
    
      <category term="RNN" scheme="https://gorillasx.github.io/tags/RNN/"/>
    
  </entry>
  
  <entry>
    <title>Implementing Interactive Physically Based Rendering On GPU notes(1)</title>
    <link href="https://gorillasx.github.io/2018/03/26/Implementing-Interactive-Physically-Based-Rendering-On-GPU-notes-1/"/>
    <id>https://gorillasx.github.io/2018/03/26/Implementing-Interactive-Physically-Based-Rendering-On-GPU-notes-1/</id>
    <published>2018-03-27T02:23:07.000Z</published>
    <updated>2018-03-28T04:18:02.666Z</updated>
    
    <content type="html"><![CDATA[<ol><li>Machine Epsilon<br>Machine Epsilon is the smallest number of EPS(epsilon) such that 1 + EPS not equal to 1. Machine Epsilon is a machine-dependent floating point value that provides an upper bound on relative error due to rounding in floating point arithmetic. In C++, similar macros are available in the standard header. The preferred way in C++ is to use std::numeric_limits::epsilon( ) – specified in the standard header.</li><li><p>usage of <strong>CUDA_ARCH</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">__device__ __<span class="function">host__ <span class="keyword">float</span> <span class="title">function</span><span class="params">(<span class="keyword">float</span> x)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> __CUDA_ARCH__</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0f</span> * __sinf(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">10.0f</span> * <span class="built_in">sin</span>(x);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><a href="https://gcc.gnu.org/onlinedocs/gcc/Diagnostic-Pragmas.html" target="_blank" rel="noopener">Diagnostic Pragmas</a></p></li><li></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;Machine Epsilon&lt;br&gt;Machine Epsilon is the smallest number of EPS(epsilon) such that 1 + EPS not equal to 1. Machine Epsilon is a ma
      
    
    </summary>
    
      <category term="Notes" scheme="https://gorillasx.github.io/categories/Notes/"/>
    
    
      <category term="CUDA" scheme="https://gorillasx.github.io/tags/CUDA/"/>
    
      <category term="Physically based rendering" scheme="https://gorillasx.github.io/tags/Physically-based-rendering/"/>
    
  </entry>
  
  <entry>
    <title>Update CUDA toolkit</title>
    <link href="https://gorillasx.github.io/2018/03/23/Update-CUDA-toolkit/"/>
    <id>https://gorillasx.github.io/2018/03/23/Update-CUDA-toolkit/</id>
    <published>2018-03-24T03:27:39.000Z</published>
    <updated>2018-04-21T16:02:36.406Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>Update Nvidia GPU Driver</p><ol><li>Log into your account in the TTY</li><li><p>Run </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get purge nvidia-*</span><br></pre></td></tr></table></figure></li><li><p>Run </p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository ppa:graphics-drivers/ppa</span><br></pre></td></tr></table></figure><p> and then</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>sudo apt-get install nvidia-390</p></li><li>Reboot</li></ol></li><li><p>Remove old CUDA toolkit</p> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get autoremove --purge cuda</span><br></pre></td></tr></table></figure></li><li><p>Install new CUDA toolkit</p><ol><li><p>Install repository meta-data</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo dpkg -i cuda-repo-&lt;distro&gt;_&lt;version&gt;_&lt;architecture&gt;.deb</span><br></pre></td></tr></table></figure></li><li><p>Installing the CUDA public GPG key<br>When installing using the local repo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key add /var/cuda-repo-&lt;version&gt;/7fa2af80.pub</span><br></pre></td></tr></table></figure><p>When installing using network repo:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-key adv --fetch-keys https://developer.download.nvidia.com/compute/cuda/repos/&lt;distro&gt;/&lt;architecture&gt;/7fa2af80.pub</span><br></pre></td></tr></table></figure></li><li><p>Update the Apt repository cache</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure></li><li><p>Install CUDA</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install cuda</span><br></pre></td></tr></table></figure></li><li><p>Environment Setup</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ export PATH=/usr/local/cuda-9.1/bin$&#123;PATH:+:$&#123;PATH&#125;&#125;</span><br><span class="line">$ export LD_LIBRARY_PATH=/usr/local/cuda-9.1/lib64$&#123;LD_LIBRARY_PATH:+:$&#123;LD_LIBRARY_PATH&#125;&#125;</span><br></pre></td></tr></table></figure></li></ol></li></ol>]]></content>
    
    <summary type="html">
    
      
      
        &lt;ol&gt;
&lt;li&gt;&lt;p&gt;Update Nvidia GPU Driver&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Log into your account in the TTY&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Run &lt;/p&gt;
 &lt;figure class=&quot;highlight bash&quot;&gt;&lt;tab
      
    
    </summary>
    
      <category term="CUDA" scheme="https://gorillasx.github.io/categories/CUDA/"/>
    
    
      <category term="CUDA" scheme="https://gorillasx.github.io/tags/CUDA/"/>
    
  </entry>
  
  <entry>
    <title>C++ virtual function table</title>
    <link href="https://gorillasx.github.io/2018/03/15/C-virtual-function-table/"/>
    <id>https://gorillasx.github.io/2018/03/15/C-virtual-function-table/</id>
    <published>2018-03-16T02:55:55.000Z</published>
    <updated>2018-03-16T04:13:43.943Z</updated>
    
    <content type="html"><![CDATA[<h4 id="There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for-understanding-C-polymorphism"><a href="#There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for-understanding-C-polymorphism" class="headerlink" title="There is a code example could be used to understand how C++ virtual function table existed and how it works. This is very important for understanding C++ polymorphism."></a>There is a code example could be used to understand how C++ virtual function table existed and how it works. This is very important for understanding C++ polymorphism.</h4><pre><code>**If there was a virtual function inside a class definition, then for each instance of this class, the first 8 bytes(64bits system) or 4 bytes(32bits system) is a pointer points to virtual function table. Virtual function table, in fact, is an arrar of function pointer, each function pointer points to a virtual function inorder as they declared. This virtual function table will be inherited by each derived class. If there are no virtual function override, then the virtual function table of derived class should be a copy of virtual function table of base class with same content. Otherwise, the virtual function table of derived class should be changed: the pointer points to the virtual function of base class should be replaced to the pointer points to virtual function of derived class**</code></pre><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Parent(<span class="keyword">int</span> x=<span class="number">8</span>):x(x)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Parent fun()"</span> &lt;&lt; <span class="built_in">endl</span>; &#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">show</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"show()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child</span>:</span><span class="keyword">public</span> Parent</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> y;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">Child(<span class="keyword">int</span> y= <span class="number">9</span>):y(y)&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">virtual</span> <span class="keyword">void</span> <span class="title">fun</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;<span class="built_in">cout</span> &lt;&lt; <span class="string">"Child fun()"</span> &lt;&lt; <span class="built_in">endl</span>;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">typedef</span> <span class="title">void</span> <span class="params">(*func)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="function">Parent <span class="title">p</span><span class="params">(<span class="number">10</span>)</span></span>;</span><br><span class="line">Child  c;</span><br><span class="line">    func** fa = <span class="keyword">reinterpret_cast</span>&lt;func**&gt;(&amp;p);</span><br><span class="line">    (*fa)[<span class="number">0</span>]();</span><br><span class="line">    (*fa)[<span class="number">1</span>]();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"father fun address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fa)[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"father show address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fa)[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">    func** fc = <span class="keyword">reinterpret_cast</span>&lt;func**&gt;(&amp;c);</span><br><span class="line">    (*fc)[<span class="number">0</span>]();</span><br><span class="line">    (*fc)[<span class="number">1</span>]();</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Children fun address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fc)[<span class="number">0</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"Children show address: "</span> &lt;&lt; <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">long</span> <span class="keyword">long</span>&gt;((*fc)[<span class="number">1</span>]) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"></span><br><span class="line">     </span><br><span class="line"> <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h4 id=&quot;There-is-a-code-example-could-be-used-to-understand-how-C-virtual-function-table-existed-and-how-it-works-This-is-very-important-for
      
    
    </summary>
    
      <category term="C++" scheme="https://gorillasx.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://gorillasx.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Decision Tree</title>
    <link href="https://gorillasx.github.io/2018/03/10/Decision-Tree/"/>
    <id>https://gorillasx.github.io/2018/03/10/Decision-Tree/</id>
    <published>2018-03-11T01:18:56.000Z</published>
    <updated>2018-03-11T01:20:37.849Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="AI" scheme="https://gorillasx.github.io/categories/AI/"/>
    
      <category term="Machine Learning" scheme="https://gorillasx.github.io/categories/AI/Machine-Learning/"/>
    
      <category term="classification" scheme="https://gorillasx.github.io/categories/AI/Machine-Learning/classification/"/>
    
    
      <category term="Machine Learning" scheme="https://gorillasx.github.io/tags/Machine-Learning/"/>
    
      <category term="classification" scheme="https://gorillasx.github.io/tags/classification/"/>
    
  </entry>
  
  <entry>
    <title>C++ template</title>
    <link href="https://gorillasx.github.io/2018/03/10/C-template/"/>
    <id>https://gorillasx.github.io/2018/03/10/C-template/</id>
    <published>2018-03-10T18:45:32.000Z</published>
    <updated>2018-03-11T00:15:53.537Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Templates"><a href="#Templates" class="headerlink" title="Templates?"></a>Templates?</h2><h3 id="What-is-templates"><a href="#What-is-templates" class="headerlink" title="What is templates?"></a>What is templates?</h3><blockquote><p>Templates are the fundation for generic programming in C++. A template is a blueprint or formula for creating classes or functions. </p></blockquote><h3 id="Why-we-need-templates"><a href="#Why-we-need-templates" class="headerlink" title="Why we need templates?"></a>Why we need templates?</h3><p>Sometimes we need to write different version of the same function or classfor different types, which will make our code fat. Thus we need templates help us solving this. </p><h3 id="How-templates-work"><a href="#How-templates-work" class="headerlink" title="How templates work?"></a>How templates work?</h3><p>Relys on type parameterization, compiler would bind, either implicitly or explicitly, template argument(s) to the template parameter(s) to generate specific function or class.</p><h2 id="Function-templates"><a href="#Function-templates" class="headerlink" title="Function templates"></a>Function templates</h2><p>A function template represents a group of functions which have the same functionality. We also can treat a function template as a formula which could be used to generate type-specific version of that function and this will be done by the compiler. </p><blockquote><p>When the compiler sees the definition of a template, it does not generate code. It genreates code only when we instantiate a specific instance of the template.</p></blockquote><p>Thus when we using a template, we need to know the definition of the template, which means when compiler need to instantiate a template, it must can see the code that defines a function template or class template member function. This is different to ordinary function. </p><blockquote><p>Ordinarily, when we call a function, the compiler needs to see only a declaration for the function. Similarity, when we use objects of class type, the class definition must be available, but the definitions of the member functions need not be present. As a result, we put class defintions and function declarations in header files adn definitions of ordinary and class-member functions in source files. </p></blockquote><p><strong>Thus, definitions of function templates and member functions of class templates are ordinarily put into header files.</strong></p><h3 id="Usage-of-a-function-template"><a href="#Usage-of-a-function-template" class="headerlink" title="Usage of a function template"></a>Usage of a function template</h3><h4 id="1-The-Definition-Of-a-Function-Template"><a href="#1-The-Definition-Of-a-Function-Template" class="headerlink" title="1. The Definition Of a Function Template"></a>1. The Definition Of a Function Template</h4><p>It should looks like:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function">T <span class="keyword">const</span>&amp; <span class="title">max</span><span class="params">(T <span class="keyword">const</span>&amp; x, T <span class="keyword">const</span>&amp; y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x &gt; y ? x : y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>A template definition starts with the keyword <em>template</em> followed by a <strong>template parameter list</strong>, which is a comma-separated list of one or more <strong>template parameters</strong> bracketed by the less-than(&lt;) and greater-than(&gt;) tokens. In a template definition, the template parameter list cannot be empty. </p></blockquote><p><strong>Template parameter list</strong> can take <strong>type parameter</strong> and <strong>nontype parameter</strong>. </p><ol><li><strong>type parameter</strong><br> A type parameter can be used to name the return type or a function parameter type, and for variable declarations or casts inside the function body. Each type parameter must be preceded by the keyword <em>class</em> or <em>typename</em>.  </li><li><p><strong>nontype parameter</strong><br> A nontype parameter represents a value rather than a type. Nontype parameters are specified by using a specific type name instead of the <em>class</em> or <em>typename</em> keyword. </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">unsigned</span> N, <span class="keyword">unsigned</span> M&gt;</span><br><span class="line">int compare(const char (&amp;p1)[N], const char (&amp;p2)[M])</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">strcmp</span>(p1, p2);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><blockquote><p>A nontype parameter may be integral type, or a pointer or (lvalue)reference to an object or to a function type. An argument bound to a nontype integral parameter must be a constant expression. Arguments bound to a pointer or reference nontype parameter must have static lifetime. </p></blockquote><h4 id="2-Instantiating-a-Function-Template"><a href="#2-Instantiating-a-Function-Template" class="headerlink" title="2. Instantiating a Function Template"></a>2. Instantiating a Function Template</h4><p>There are two ways to instantiate a function template, and the type used to instantiate the template must satisfy the operation of that type inside the definition of that function template:</p><ol><li>Explicit way:</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; max&lt;<span class="keyword">int</span>&gt;(<span class="number">123</span>, <span class="number">234</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><ol><li>Implicit way</li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cout</span> &lt;&lt; max(<span class="number">234</span>,<span class="number">567</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><h2 id="Class-templates"><a href="#Class-templates" class="headerlink" title="Class templates"></a>Class templates</h2>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Templates&quot;&gt;&lt;a href=&quot;#Templates&quot; class=&quot;headerlink&quot; title=&quot;Templates?&quot;&gt;&lt;/a&gt;Templates?&lt;/h2&gt;&lt;h3 id=&quot;What-is-templates&quot;&gt;&lt;a href=&quot;#What-i
      
    
    </summary>
    
      <category term="C++" scheme="https://gorillasx.github.io/categories/C/"/>
    
    
      <category term="C++" scheme="https://gorillasx.github.io/tags/C/"/>
    
  </entry>
  
  <entry>
    <title>Let&#39;s get started</title>
    <link href="https://gorillasx.github.io/2018/03/01/Let-s-get-started/"/>
    <id>https://gorillasx.github.io/2018/03/01/Let-s-get-started/</id>
    <published>2018-03-01T07:10:43.000Z</published>
    <updated>2018-03-01T07:11:27.106Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Let’s-get-started"><a href="#Let’s-get-started" class="headerlink" title="Let’s get started"></a>Let’s get started</h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;Let’s-get-started&quot;&gt;&lt;a href=&quot;#Let’s-get-started&quot; class=&quot;headerlink&quot; title=&quot;Let’s get started&quot;&gt;&lt;/a&gt;Let’s get started&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
